*Core.hs*:

`

{-# LANGUAGE LambdaCase #-}

{-# LANGUAGE PatternSynonyms #-}

{-# LANGUAGE DeriveFunctor #-}

{-# LANGUAGE GeneralizedNewtypeDeriving #-}



module Assembly.Core (

    -- Core Types

    Address,

    Label,

    ProgramCounter,

    LabelExpression(..), -- New type for label arithmetic

    AddressRef(..),

    AddressingMode(..),

    Operand(..),

    pattern Imm,

    pattern AbsLit,

    pattern AbsAddress,

    pattern AbsLabel,

    pattern AbsXLit,

    pattern AbsXLabel,

    pattern ZPLabel,

    zpLit,

    pattern Ind,

    pattern IndX,

    pattern IndY,

    pattern ZPX,

    pattern ZPY,

    pattern AbsYLabel,

    pattern AbsYLit,

    BranchMnemonic(..),

    Mnemonic(..),

    SymbolicInstruction(..),

    Directive(..), -- NEW: Represents directives like ORG



    -- Core State & Monad

    AsmState(..),

    initialAsmState,

    Asm(..),



    -- Core Primitives (niektóre zostaną zmodyfikowane)

    getInstructionInfo, -- NOWA FUNKCJA ZAMIAST getInstructionSize/operandOpcode

    getInstructionSize, -- ZOSTANIE ZMODYFIKOWANA/USUNIĘTA

    emitGeneric,

    emitIns,

    emitImplied, -- MOŻE BYĆ ZMODYFIKOWANY

    emitAccumulator, -- NOWY

    emitBranch,

    l_,

    db, -- Renamed

    dw, -- Renamed

    string, -- Renamed

    immChar,

    stringPETSCI, -- NEW: PETSCII string function

    stringC64, -- NEW: PETSCII string function for screen codes

    org, -- Renamed & Export the org directive function

    makeUniqueLabel,

    makeLabelWithPrefix,

    generateInstructionBytes,



    -- Opcode-related functions (teraz oparte na tabeli)

    instructionTable, -- NOWA TABELA

    getOperandAddressingMode, -- NOWA FUNKCJA POMOCNICZA

    resolveAddressMaybe, -- ISTNIEJĄCA

    getOperandAddressRef, -- ISTNIEJĄCA

    branchOpcode, -- NOWA FUNKCJA POMOCNICZA



    -- Miscellaneous

    lo,

    hi,

    hx,

    asc,

    addr2word16,

    evalLabelExpr, -- NEW EXPORT

    wordToBytesLE, -- Added export

    (.+) , -- Renamed operator for AddressRef

    (.-), -- Renamed operator for AddressRef

    parens,            -- function for wrapping AddressRef in parentheses



    -- New typeclass for arithmetic expressions and its methods

    ArithExpr(add, sub),



    -- eDSL Instruction Aliases

    lda, sta, ldx, ldy, jmp, inx, adc, sbc, tax, tay, stx, sty,

    cmp, cpx, cpy, txa, tya, txs, tsx, bne, beq, bcs, bcc, bmi,

    bpl, bvs, bvc, jsr, rts, ora, asl, php, clc, and, bit, rol,

    ror, plp, sec, rti, eor, lsr, pha, cli, pla, sei, dey, clv,

    iny, dex, cld, nop, sed, inc, dec, brk

) where



import Prelude hiding (and, or) -- Hiding only 'and', 'or'

import qualified Prelude as P (and, or)  -- Use P.(+) and P.(-) for standard numeric ops

import Control.Monad.State.Strict

import Control.Monad (when)

import Data.Word

import Data.Int (Int8)

import Data.Bits ((.&.), shiftR)

import qualified Data.Map.Strict as Map

import Data.Map.Strict (Map) -- Jawny import dla Map

import Data.Maybe (fromMaybe) -- Potrzebne dla lookupów

import Data.Char (ord, chr, isDigit, isAsciiUpper, isAsciiLower)

import Numeric (showHex)

import Data.List (foldl') -- Potrzebne do budowania tabeli



import Assembly.Branch (BranchMnemonic(..)) -- Importujemy BranchMnemonic z osobnego modułu

import Assembly.Instructions6502 (getModeSize, instructionData, Mnemonic(..), AddressingMode(..))



-- --- Types ---

type Address = Word16

type Label = String

type ProgramCounter = Word16



-- New type for label arithmetic expressions

data LabelExpression

  = LabelRef Label

  | LabelAdd LabelExpression Word16

  | LabelSub LabelExpression Word16

  | LabelParen LabelExpression

  deriving (Show, Eq, Ord)



-- Updated AddressRef to include label expressions

data AddressRef

  = AddrLit16 Word16

  | AddrLabel Label

  | AddrLabelExpr LabelExpression

  deriving (Show, Eq, Ord)



-- Renamed operators for AddressRef

infixl 6 .+

(.+):: AddressRef -> Word16 -> AddressRef

a .+ i  =

    case a of

        AddrLit16 v -> AddrLit16 (v + i) -- Use P.(+) for Word16 addition

        AddrLabel l -> AddrLabelExpr (LabelAdd (LabelRef l) i)

        AddrLabelExpr expr -> AddrLabelExpr (LabelAdd expr i)



infixl 6 .-

(.-) :: AddressRef -> Word16 -> AddressRef

a .- i =

  case a of

    AddrLit16 v -> AddrLit16 (v - i) -- Use P.(-) for Word16 subtraction

    AddrLabel l -> AddrLabelExpr (LabelSub (LabelRef l) i)

    AddrLabelExpr expr -> AddrLabelExpr (LabelSub expr i)



-- New typeclass for arithmetic expressions

class ArithExpr a where

  add :: a -> Word16 -> a

  sub :: a -> Word16 -> a



-- Instance using the renamed operators

instance ArithExpr AddressRef where

  add = (.+)

  sub = (.-)



-- Updated Operand to match AddressingMode

data Operand

    = OpImm Word8          -- Immediate

    | OpZP AddressRef      -- ZeroPage

    | OpZPX AddressRef     -- ZeroPageX

    | OpZPY AddressRef     -- ZeroPageY

    | OpAbs AddressRef     -- Absolute

    | OpAbsX AddressRef    -- AbsoluteX

    | OpAbsY AddressRef    -- AbsoluteY

    | OpInd AddressRef     -- Indirect (tylko JMP)

    | OpIndX AddressRef    -- IndirectX ($NN,X)

    | OpIndY AddressRef    -- IndirectY ($NN),Y

    -- Brak konstruktora dla Implicit, Accumulator, Relative - są obsługiwane inaczej

    deriving (Show, Eq)



-- Pattern Synonyms (aktualizacja i dodanie nowych)

pattern Imm :: Word8 -> Operand; pattern Imm v = OpImm v

-- pattern ImmChar :: Char -> Operand; pattern ImmChar v = OpImm (fromIntegral (ord v))

pattern AbsLit :: Word16 -> Operand; pattern AbsLit v = OpAbs (AddrLit16 v)

pattern AbsAddress :: AddressRef -> Operand; pattern AbsAddress v = OpAbs v

pattern AbsLabel :: Label -> Operand; pattern AbsLabel l = OpAbs (AddrLabel l)

pattern AbsXLit :: Word16 -> Operand; pattern AbsXLit v = OpAbsX (AddrLit16 v)

pattern AbsXLabel :: Label -> Operand; pattern AbsXLabel l = OpAbsX (AddrLabel l)

pattern AbsYLit :: Word16 -> Operand; pattern AbsYLit v = OpAbsY (AddrLit16 v)

pattern AbsYLabel :: Label -> Operand; pattern AbsYLabel l = OpAbsY (AddrLabel l)

pattern ZPLabel :: Label -> Operand; pattern ZPLabel l = OpZP (AddrLabel l)

zpLit :: Word8 -> Operand; zpLit v = OpZP (AddrLit16 (fromIntegral v))

pattern ZPX :: AddressRef -> Operand; pattern ZPX r = OpZPX r

pattern ZPY :: AddressRef -> Operand; pattern ZPY r = OpZPY r

pattern Ind :: AddressRef -> Operand; pattern Ind r = OpInd r

pattern IndX :: AddressRef -> Operand; pattern IndX r = OpIndX r

pattern IndY :: AddressRef -> Operand; pattern IndY r = OpIndY r



-- NEW: Represents directives that don't directly generate code but affect assembly

newtype Directive = DOrg Address deriving (Show, Eq) -- HLint: Use newtype



-- SymbolicInstruction (updated to include directives)

data SymbolicInstruction

    = SLabelDef Label

    | SIns Mnemonic (Maybe Operand)

    | SBranch BranchMnemonic Label

    | SBytes [Word8]

    | SWords [Word16]

    | SDirective Directive -- NEW: Add directives here

    deriving (Show, Eq)





-- --- Assembler State (bez zmian) ---

data AsmState = AsmState

  { asmPC            :: ProgramCounter

  , asmLabels        :: Map.Map Label ProgramCounter

  , asmCode          :: [(ProgramCounter, SymbolicInstruction)]

  , asmMacroCounter  :: Int

  } deriving (Show)



initialAsmState :: ProgramCounter -> AsmState

initialAsmState startAddr = AsmState startAddr Map.empty [] 0



-- --- Assembler Monad (bez zmian) ---

newtype Asm a = Asm { unAsm :: State AsmState a }

  deriving (Functor, Applicative, Monad, MonadState AsmState)



-- --- Tabela Instrukcji ---



-- Typ dla wpisu w tabeli: (Opcode, Rozmiar w bajtach)

type OpcodeEntry = (Word8, Word8)



-- Główna tabela instrukcji: Mapa z Mnemonic na mapę z AddressingMode na OpcodeEntry

instructionTable :: Map Mnemonic (Map AddressingMode OpcodeEntry)

instructionTable = buildInstructionTable instructionData



-- Funkcja pomocnicza do konwersji (przeniesiona/utworzona tutaj)

branchMnemonicToMnemonic :: BranchMnemonic -> Mnemonic

branchMnemonicToMnemonic = \case

    Assembly.Branch.B_BNE -> BNE;

    Assembly.Branch.B_BEQ -> BEQ;

    Assembly.Branch.B_BCS -> BCS;

    Assembly.Branch.B_BCC -> BCC;

    Assembly.Branch.B_BMI -> BMI;

    Assembly.Branch.B_BPL -> BPL;

    Assembly.Branch.B_BVS -> BVS;

    Assembly.Branch.B_BVC -> BVC;

    -- Te konstruktory po prawej stronie odnoszą się teraz do typu Mnemonic z Instructions6502



-- Funkcja do pobierania opkodu (przeniesiona i zmodyfikowana z Core.hs)

-- Używa teraz instructionTable z Core.hs

branchOpcode :: BranchMnemonic -> Word8

branchOpcode bm =

    let mnemonic = branchMnemonicToMnemonic bm

    in case Map.lookup mnemonic instructionTable >>= Map.lookup Relative of

        Just (opcode, _size) -> opcode

        Nothing -> error $ "Internal error: Opcode for branch " ++ show bm ++ " not found in instruction table."





-- Funkcja budująca główną tabelę instrukcji

buildInstructionTable :: [(Mnemonic, AddressingMode, Word8)] -> Map Mnemonic (Map AddressingMode OpcodeEntry)

buildInstructionTable = foldl' insertInstruction Map.empty

  where

    insertInstruction table (mnemonic, mode, opcode) =

      let size = getModeSize mode

          entry = (opcode, size)

          modeMap = Map.singleton mode entry

      in Map.insertWith Map.union mnemonic modeMap table



-- NOWA: Funkcja pomocnicza do mapowania Operandu na AddressingMode

-- Dla Implicit/Accumulator potrzebujemy mnemonika

getOperandAddressingMode :: Mnemonic -> Maybe Operand -> Either String AddressingMode

getOperandAddressingMode _ (Just (OpImm _))   = Right Immediate

getOperandAddressingMode _ (Just (OpZP _))    = Right ZeroPage

getOperandAddressingMode _ (Just (OpZPX _))   = Right ZeroPageX

getOperandAddressingMode _ (Just (OpZPY _))   = Right ZeroPageY

getOperandAddressingMode _ (Just (OpAbs _))   = Right Absolute

getOperandAddressingMode _ (Just (OpAbsX _))  = Right AbsoluteX

getOperandAddressingMode _ (Just (OpAbsY _))  = Right AbsoluteY

getOperandAddressingMode _ (Just (OpInd _))   = Right Indirect

getOperandAddressingMode _ (Just (OpIndX _))  = Right IndirectX

getOperandAddressingMode _ (Just (OpIndY _))  = Right IndirectY

getOperandAddressingMode m Nothing = case m of

    -- Sprawdzanie czy mnemonic obsługuje tryb Accumulator

    ASL -> Right Accumulator

    LSR -> Right Accumulator

    ROL -> Right Accumulator

    ROR -> Right Accumulator

    -- W przeciwnym razie zakładamy Implicit (lub błąd, jeśli nie ma wpisu)

    _   -> Right Implicit



-- NOWA: Funkcja do pobierania informacji o instrukcji (opcode i rozmiar)

getInstructionInfo :: Mnemonic -> Maybe Operand -> Either String OpcodeEntry

getInstructionInfo m maybeOp = do

    mode <- getOperandAddressingMode m maybeOp

    case Map.lookup m instructionTable >>= Map.lookup mode of

        Just entry -> Right entry

        Nothing    -> Left $ "Unsupported addressing mode '" ++ show mode ++ "' for mnemonic '" ++ show m ++ "'"



-- --- Core Primitive Functions (MODYFIKACJE) ---



-- resolveAddressMaybe (updated to handle AddrLabelExpr and LabelParen)

resolveAddressMaybe :: Maybe AddressRef -> AsmState -> Maybe Word16

resolveAddressMaybe Nothing _ = Just 0 -- For Imm, value doesn't matter

resolveAddressMaybe (Just (AddrLit16 v)) _ = Just v

resolveAddressMaybe (Just (AddrLabel l)) s = Map.lookup l (asmLabels s)

resolveAddressMaybe (Just (AddrLabelExpr expr)) s = resolveLabelExpr expr (asmLabels s)

  where

    resolveLabelExpr :: LabelExpression -> Map Label ProgramCounter -> Maybe Word16

    resolveLabelExpr (LabelRef l) labels = Map.lookup l labels

    resolveLabelExpr (LabelAdd subExpr offset) labels = (+) offset <$> resolveLabelExpr subExpr labels -- Use P.(+)

    resolveLabelExpr (LabelSub subExpr offset) labels = subtract offset <$> resolveLabelExpr subExpr labels -- Using subtract for correct order

    resolveLabelExpr (LabelParen subExpr) labels = resolveLabelExpr subExpr labels -- Handle LabelParen



-- getInstructionSize (now uses getInstructionInfo)

getInstructionSize :: Mnemonic -> Maybe Operand -> Either String Word16

getInstructionSize m maybeOp = fmap (fromIntegral . snd) (getInstructionInfo m maybeOp)



-- emitGeneric (Use P.(+) for PC update)

emitGeneric :: SymbolicInstruction -> Either String Word16 -> Asm ()

emitGeneric _ (Left err) = error $ "Assembly Error (emitGeneric): " ++ err -- TODO: Lepsza obsługa błędów

emitGeneric instruction (Right size) = do

  pc <- gets asmPC

  modify' $ \s -> s { asmCode = (pc, instruction) : asmCode s, asmPC = pc + size }



-- emitIns (bez zmian, ale używa zaktualizowanego getInstructionSize)

emitIns :: Mnemonic -> Operand -> Asm ()

emitIns m op = emitGeneric (SIns m (Just op)) (getInstructionSize m (Just op))



-- emitImplied (używa teraz SIns m Nothing)

emitImplied :: Mnemonic -> Asm ()

emitImplied m = emitGeneric (SIns m Nothing) (getInstructionSize m Nothing)



-- NOWA: emitAccumulator (dla jasności, chociaż technicznie to też SIns m Nothing)

emitAccumulator :: Mnemonic -> Asm ()

emitAccumulator m = emitGeneric (SIns m Nothing) (getInstructionSize m Nothing)



-- emitBranch (bez zmian)

emitBranch :: BranchMnemonic -> Label -> Asm ()

emitBranch m l = emitGeneric (SBranch m l) (Right 2)



-- NEW: org directive function

-- Sets the program counter to a specific address.

org :: Address -> Asm ()

org addr = do

    pc <- gets asmPC -- Get current PC for the record, though it doesn't generate bytes

    -- Add the directive instruction to the code list

    modify' $ \s -> s { asmCode = (pc, SDirective (DOrg addr)) : asmCode s }

    -- Set the program counter to the new address

    modify' $ \s -> s { asmPC = addr }



-- l_ (bez zmian)

l_ :: Label -> Asm ()

l_ lbl = do pc <- gets asmPC; labels <- gets asmLabels

            when (Map.member lbl labels) $ error $ "Label redefined: " ++ lbl -- TODO: Lepsza obsługa błędów

            modify' $ \s -> s { asmLabels = Map.insert lbl pc labels }

            emitGeneric (SLabelDef lbl) (Right 0)



-- db, dw, string (Renamed)

db :: [Word8] -> Asm (); db bs = let size = fromIntegral $ length bs in when (size > 0) $ emitGeneric (SBytes bs) (Right size)

dw :: [Word16] -> Asm (); dw ws = let size = fromIntegral (length ws) * 2 in when (size > 0) $ emitGeneric (SWords ws) (Right size)

string :: String -> Asm (); string str = let bytes = map (fromIntegral . ord) str; size = fromIntegral $ length bytes in when (size > 0) $ emitGeneric (SBytes bytes) (Right size)



immChar :: Char -> Operand; immChar v = OpImm (fromIntegral (ord v))



-- NEW: stringPETSCI function for PETSCII encoding

stringPETSCI :: String -> Asm ()

stringPETSCI str =

  let

    -- Simple PETSCII conversion (basic characters)

    petscii :: Char -> Word8

    petscii c = case c of

      c' | isAsciiUpper c' -> fromIntegral (ord c' + 128) -- Uppercase letters

        | isAsciiLower c' -> fromIntegral (ord c' - 32)  -- Lowercase to uppercase PETSCII

      ' '      -> 32                         -- Space

      _        -> fromIntegral (ord c)       -- Other characters (basic assumption)

    bytes = map petscii str

    size = fromIntegral $ length bytes

  in when (size > 0) $ emitGeneric (SBytes bytes) (Right size)



stringC64 :: String -> Asm ()

stringC64  str =

  let

    -- Simple PETSCII conversion (basic characters)

    asciiToScreencode :: Char -> Word8

    asciiToScreencode c

      | isAsciiUpper c = fromIntegral (ord c - 64)          -- A-Z: 65-90 -> 1-26

      | isAsciiLower c = fromIntegral (ord c - 96)          -- a-z: 97-122 -> 1-26 (mapowane na wielkie)

      | isDigit c      = fromIntegral (ord c - 48 + 48)     -- 0-9: 48-57 -> 48-57

      | c == ' '             =  32                    -- Spacja: 32

      | c == '@'             =  0                     -- @: 0

      | c == '$'             =  36                    -- $: 36

      | otherwise            =  63                    -- Nieobsługiwane znaki: ? (63)

    bytes = map asciiToScreencode str

    size = fromIntegral $ length bytes

  in when (size > 0) $ emitGeneric (SBytes bytes) (Right size)





-- makeUniqueLabel_ (Use P.(+) for counter update)

makeUniqueLabel_ :: String -> Asm Label

makeUniqueLabel_ prefix = do

    count <- gets asmMacroCounter

    modify' $ \s -> s { asmMacroCounter = count + 1 }

    return $ "_lbl_" ++ prefix ++ "_" ++ show count



makeUniqueLabel :: () -> Asm Label

makeUniqueLabel _ = makeUniqueLabel_ ""



makeLabelWithPrefix :: String -> Asm Label

makeLabelWithPrefix = makeUniqueLabel_





-- --- Opcode-related functions (USUNIĘTE/ZASTĄPIONE) ---

-- impliedOpcode, operandOpcode zostają zastąpione przez logikę w generateBinary używającą instructionTable



-- Funkcja pomocnicza dla generateBinary (może być w Assembly.hs)

generateInstructionBytes :: Mnemonic -> Maybe Operand -> AsmState -> Either String [Word8]

generateInstructionBytes m maybeOp asmState = do

    (opcode, size) <- getInstructionInfo m maybeOp

    addressRef <- Right $ getOperandAddressRef maybeOp -- Pobierz AddressRef, jeśli istnieje

    resolvedAddrMaybe <- Right $ resolveAddressMaybe addressRef asmState



    case resolvedAddrMaybe of

        Nothing | size > 1 && maybeOp /= Nothing -> Left $ "Failed to resolve address for " ++ show m ++ " " ++ show maybeOp -- Błąd jeśli adres jest potrzebny a nie da się go rozwiązać

        _ -> let resolvedAddr = fromMaybe 0 resolvedAddrMaybe -- Domyślnie 0 jeśli niepotrzebny (np. Imm) lub błąd

                 operandVal = case maybeOp of Just (OpImm v) -> v; _ -> 0 -- Pobierz wartość dla Immediate

             in Right $ case size of

                 1 -> [opcode]

                 2 -> case fromMaybe Implicit (either (const Nothing) Just (getOperandAddressingMode m maybeOp)) of -- Potrzebujemy trybu, aby odróżnić Imm od innych 2-bajtowych

                          Immediate -> [opcode, operandVal]

                          _         -> [opcode, lo resolvedAddr] -- ZP, ZPX, ZPY, IndX, IndY

                 3 -> [opcode, lo resolvedAddr, hi resolvedAddr] -- Abs, AbsX, AbsY, Ind

                 _ -> error "Internal error: Invalid instruction size derived" -- Nie powinno się zdarzyć



-- getOperandAddressRef (no changes needed, extracts AddressRef)

getOperandAddressRef :: Maybe Operand -> Maybe AddressRef

getOperandAddressRef = \case

    Just (OpZP r)   -> Just r

    Just (OpZPX r)  -> Just r

    Just (OpZPY r)  -> Just r

    Just (OpAbs r)  -> Just r

    Just (OpAbsX r) -> Just r

    Just (OpAbsY r) -> Just r

    Just (OpInd r)  -> Just r

    Just (OpIndX r) -> Just r

    Just (OpIndY r) -> Just r

    _               -> Nothing -- Dla Imm, Implicit, Accumulator





-- --- Miscellaneous ---

lo :: Word16 -> Word8; lo = fromIntegral . (.&. 0xFF)

hi :: Word16 -> Word8; hi w = fromIntegral (w `shiftR` 8)

hx :: Word16 -> String; hx a = showHex a ""

wordToBytesLE :: Word16 -> [Word8]; wordToBytesLE w = [lo w, hi w]



-- Top-level function for testing

evalLabelExpr :: LabelExpression -> Word16

evalLabelExpr = \case

  LabelRef l -> error $ "Compile-time error: Cannot get value of unresolved label '" ++ l ++ "' within expression"

  LabelParen expr -> evalLabelExpr expr

  LabelAdd subExpr offset -> evalLabelExpr subExpr + offset -- Use P.(+)

  LabelSub subExpr offset -> evalLabelExpr subExpr - offset -- Use P.(-)



-- addrVal using evalLabelExpr

addr2word16 :: AddressRef -> Word16

addr2word16 = \case

  AddrLit16 v -> v

  AddrLabel l -> error $ "Compile-time error!!: Cannot get value of unresolved label '" ++ l ++ "'"

  AddrLabelExpr expr -> evalLabelExpr expr



-- parens function definition

parens :: AddressRef -> AddressRef

parens (AddrLabelExpr e) = AddrLabelExpr (LabelParen e)

parens addr = addr



-- Character to ASCII code

asc :: Char -> Word8

asc = fromIntegral . fromEnum



-- --- eDSL Instruction Aliases ---

lda :: Operand -> Asm (); lda = emitIns LDA

sta :: Operand -> Asm (); sta = emitIns STA

ldx :: Operand -> Asm (); ldx = emitIns LDX

ldy :: Operand -> Asm (); ldy = emitIns LDY

jmp :: Operand -> Asm (); jmp = emitIns JMP

inx :: Asm (); inx = emitImplied INX

rts :: Asm (); rts = emitImplied RTS

adc :: Operand -> Asm (); adc = emitIns ADC

sbc :: Operand -> Asm (); sbc = emitIns SBC

tax :: Asm (); tax = emitImplied TAX

tay :: Asm (); tay = emitImplied TAY

txa :: Asm (); txa = emitImplied TXA

tya :: Asm (); tya = emitImplied TYA

txs :: Asm (); txs = emitImplied TXS

tsx :: Asm (); tsx = emitImplied TSX

stx :: Operand -> Asm (); stx = emitIns STX

sty :: Operand -> Asm (); sty = emitIns STY

cmp :: Operand -> Asm (); cmp = emitIns CMP

cpx :: Operand -> Asm (); cpx = emitIns CPX

cpy :: Operand -> Asm (); cpy = emitIns CPY

bne :: Label -> Asm (); bne = emitBranch B_BNE

beq :: Label -> Asm (); beq = emitBranch B_BEQ

bcs :: Label -> Asm (); bcs = emitBranch B_BCS

bcc :: Label -> Asm (); bcc = emitBranch B_BCC

bmi :: Label -> Asm (); bmi = emitBranch B_BMI

bpl :: Label -> Asm (); bpl = emitBranch B_BPL

bvs :: Label -> Asm (); bvs = emitBranch B_BVS

bvc :: Label -> Asm (); bvc = emitBranch B_BVC

jsr :: Operand -> Asm (); jsr = emitIns JSR

ora :: Operand -> Asm (); ora = emitIns ORA

asl :: Maybe Operand -> Asm ()

asl Nothing   = emitAccumulator ASL

asl (Just op) = emitIns ASL op

php :: Asm (); php = emitImplied PHP

clc :: Asm (); clc = emitImplied CLC

and :: Operand -> Asm (); and = emitIns AND

bit :: Operand -> Asm (); bit = emitIns BIT

rol :: Maybe Operand -> Asm ()

rol Nothing   = emitAccumulator ROL

rol (Just op) = emitIns ROL op

plp :: Asm (); plp = emitImplied PLP

sec :: Asm (); sec = emitImplied SEC

rti :: Asm (); rti = emitImplied RTI

eor :: Operand -> Asm (); eor = emitIns EOR

lsr :: Maybe Operand -> Asm ()

lsr Nothing   = emitAccumulator LSR

lsr (Just op) = emitIns LSR op

pha :: Asm (); pha = emitImplied PHA

cli :: Asm (); cli = emitImplied CLI

pla :: Asm (); pla = emitImplied PLA

sei :: Asm (); sei = emitImplied SEI

dey :: Asm (); dey = emitImplied DEY

clv :: Asm (); clv = emitImplied CLV

iny :: Asm (); iny = emitImplied INY

dex :: Asm (); dex = emitImplied DEX

cld :: Asm (); cld = emitImplied CLD

nop :: Asm (); nop = emitImplied NOP

sed :: Asm (); sed = emitImplied SED

inc :: Operand -> Asm (); inc = emitIns INC

dec :: Operand -> Asm (); dec = emitIns DEC

brk :: Asm (); brk = emitImplied BRK

ror :: Maybe Operand -> Asm ()

ror Nothing   = emitAccumulator ROR

ror (Just op) = emitIns ROR op

`

*Branch.hs*:

`



module Assembly.Branch (

    BranchMnemonic(..),

    -- Nie eksportujemy emitBranch bezpośrednio stąd,

    -- lepiej żeby główny moduł Assembly go re-eksportował

    -- jeśli jest potrzebny użytkownikowi końcowemu.

    -- Funkcje pomocnicze jak emitBranch będą używane wewnętrznie.

) where



import Data.Word (Word8)

import qualified Data.Map.Strict as Map

-- WAŻNE: Importujemy potrzebne rzeczy z Core

-- import Assembly.Core.Types (Mnemonic(..), AddressingMode(..), instructionTable) -- Załóżmy, że typy są w Core.Types



-- Definicja przeniesiona z Core.hs

data BranchMnemonic = B_BNE | B_BEQ | B_BCS | B_BCC | B_BMI | B_BPL | B_BVS | B_BVC

    deriving (Show, Eq, Ord, Enum, Bounded)

`

*Instructions6502.hs*:

`

{-# LANGUAGE LambdaCase #-}





module Assembly.Instructions6502 (

    AddressingMode(..),

    Mnemonic(..),

    instructionData,

    getModeSize,

) where

import Data.Word (Word8)

import GHC.Generics (Generic)

import qualified Data.Map.Strict as Map







-- NOWY: Enum dla wszystkich trybów adresowania

data AddressingMode

    = Implicit

    | Accumulator

    | Immediate

    | ZeroPage

    | ZeroPageX

    | ZeroPageY

    | Absolute

    | AbsoluteX

    | AbsoluteY

    | Indirect

    | IndirectX -- (zp,X)

    | IndirectY -- (zp),Y

    | Relative -- Specjalny dla skoków

    deriving (Show, Eq, Ord, Enum, Bounded)



-- Funkcja pomocnicza do obliczania rozmiaru na podstawie trybu adresowania

getModeSize :: AddressingMode -> Word8

getModeSize = \case

    Implicit      -> 1

    Accumulator   -> 1

    Immediate     -> 2

    ZeroPage      -> 2

    ZeroPageX     -> 2

    ZeroPageY     -> 2

    Absolute      -> 3

    AbsoluteX     -> 3

    AbsoluteY     -> 3

    Indirect      -> 3 -- Tylko JMP

    IndirectX     -> 2

    IndirectY     -> 2

    Relative      -> 2 -- Skoki warunkowe





-- ZAKTUALIZOWANY: Enum dla wszystkich mnemoników 6502

data Mnemonic

    = ADC | AND | ASL | BCC | BCS | BEQ | BIT | BMI | BNE | BPL | BRK | BVC | BVS | CLC

    | CLD | CLI | CLV | CMP | CPX | CPY | DEC | DEX | DEY | EOR | INC | INX | INY | JMP

    | JSR | LDA | LDX | LDY | LSR | NOP | ORA | PHA | PHP | PLA | PLP | ROL | ROR | RTI

    | RTS | SBC | SEC | SED | SEI | STA | STX | STY | TAX | TAY | TSX | TXA | TXS | TYA

    deriving (Show, Eq, Ord, Enum, Bounded)





-- Surowe dane instrukcji: Lista (Mnemonic, AddressingMode, Opcode) - rozmiar zostanie dodany

-- Na podstawie listy OCaml, przekonwertowane na Hex i z odpowiednimi typami Haskell

instructionData :: [(Mnemonic, AddressingMode, Word8)]

instructionData = [

    (BRK, Implicit, 0x00),

    (ORA, IndirectX, 0x01),

    (ORA, ZeroPage, 0x05),

    (ASL, ZeroPage, 0x06),

    (PHP, Implicit, 0x08),

    (ORA, Immediate, 0x09),

    (ASL, Accumulator, 0x0A),

    (ORA, Absolute, 0x0D),

    (ASL, Absolute, 0x0E),

    (BPL, Relative, 0x10),

    (ORA, IndirectY, 0x11),

    (ORA, ZeroPageX, 0x15),

    (ASL, ZeroPageX, 0x16),

    (CLC, Implicit, 0x18),

    (ORA, AbsoluteY, 0x19),

    (ORA, AbsoluteX, 0x1D),

    (ASL, AbsoluteX, 0x1E),

    (JSR, Absolute, 0x20),

    (AND, IndirectX, 0x21),

    (BIT, ZeroPage, 0x24),

    (AND, ZeroPage, 0x25),

    (ROL, ZeroPage, 0x26),

    (PLP, Implicit, 0x28),

    (AND, Immediate, 0x29),

    (ROL, Accumulator, 0x2A),

    (BIT, Absolute, 0x2C),

    (AND, Absolute, 0x2D),

    (ROL, Absolute, 0x2E),

    (BMI, Relative, 0x30),

    (AND, IndirectY, 0x31),

    (AND, ZeroPageX, 0x35),

    (ROL, ZeroPageX, 0x36),

    (SEC, Implicit, 0x38),

    (AND, AbsoluteY, 0x39),

    (AND, AbsoluteX, 0x3D),

    (ROL, AbsoluteX, 0x3E),

    (RTI, Implicit, 0x40),

    (EOR, IndirectX, 0x41),

    (EOR, ZeroPage, 0x45),

    (LSR, ZeroPage, 0x46),

    (PHA, Implicit, 0x48),

    (EOR, Immediate, 0x49),

    (LSR, Accumulator, 0x4A),

    (JMP, Absolute, 0x4C),

    (EOR, Absolute, 0x4D),

    (LSR, Absolute, 0x4E),

    (BVC, Relative, 0x50),

    (EOR, IndirectY, 0x51),

    (EOR, ZeroPageX, 0x55),

    (LSR, ZeroPageX, 0x56),

    (CLI, Implicit, 0x58),

    (EOR, AbsoluteY, 0x59),

    (EOR, AbsoluteX, 0x5D),

    (LSR, AbsoluteX, 0x5E),

    (RTS, Implicit, 0x60),

    (ADC, IndirectX, 0x61),

    (ADC, ZeroPage, 0x65),

    (ROR, ZeroPage, 0x66),

    (PLA, Implicit, 0x68),

    (ADC, Immediate, 0x69),

    (ROR, Accumulator, 0x6A),

    (JMP, Indirect, 0x6C),

    (ADC, Absolute, 0x6D),

    (ROR, Absolute, 0x6E),

    (BVS, Relative, 0x70),

    (ADC, IndirectY, 0x71),

    (ADC, ZeroPageX, 0x75),

    (ROR, ZeroPageX, 0x76),

    (SEI, Implicit, 0x78),

    (ADC, AbsoluteY, 0x79),

    (ADC, AbsoluteX, 0x7D),

    (ROR, AbsoluteX, 0x7E),

    (STA, IndirectX, 0x81),

    (STY, ZeroPage, 0x84),

    (STA, ZeroPage, 0x85),

    (STX, ZeroPage, 0x86),

    (DEY, Implicit, 0x88),

    (TXA, Implicit, 0x8A),

    (STY, Absolute, 0x8C),

    (STA, Absolute, 0x8D),

    (STX, Absolute, 0x8E),

    (BCC, Relative, 0x90),

    (STA, IndirectY, 0x91),

    (STY, ZeroPageX, 0x94),

    (STA, ZeroPageX, 0x95),

    (STX, ZeroPageY, 0x96),

    (TYA, Implicit, 0x98),

    (STA, AbsoluteY, 0x99),

    (TXS, Implicit, 0x9A),

    (STA, AbsoluteX, 0x9D),

    (LDY, Immediate, 0xA0),

    (LDA, IndirectX, 0xA1),

    (LDX, Immediate, 0xA2),

    (LDY, ZeroPage, 0xA4),

    (LDA, ZeroPage, 0xA5),

    (LDX, ZeroPage, 0xA6),

    (TAY, Implicit, 0xA8),

    (LDA, Immediate, 0xA9),

    (TAX, Implicit, 0xAA),

    (LDY, Absolute, 0xAC),

    (LDA, Absolute, 0xAD),

    (LDX, Absolute, 0xAE),

    (BCS, Relative, 0xB0),

    (LDA, IndirectY, 0xB1),

    (LDY, ZeroPageX, 0xB4),

    (LDA, ZeroPageX, 0xB5),

    (LDX, ZeroPageY, 0xB6),

    (CLV, Implicit, 0xB8),

    (LDA, AbsoluteY, 0xB9),

    (TSX, Implicit, 0xBA),

    (LDY, AbsoluteX, 0xBC),

    (LDA, AbsoluteX, 0xBD),

    (LDX, AbsoluteY, 0xBE),

    (CPY, Immediate, 0xC0),

    (CMP, IndirectX, 0xC1),

    (CPY, ZeroPage, 0xC4),

    (CMP, ZeroPage, 0xC5),

    (DEC, ZeroPage, 0xC6),

    (INY, Implicit, 0xC8),

    (CMP, Immediate, 0xC9),

    (DEX, Implicit, 0xCA),

    (CPY, Absolute, 0xCC),

    (CMP, Absolute, 0xCD),

    (DEC, Absolute, 0xCE),

    (BNE, Relative, 0xD0),

    (CMP, IndirectY, 0xD1),

    (CMP, ZeroPageX, 0xD5),

    (DEC, ZeroPageX, 0xD6),

    (CLD, Implicit, 0xD8),

    (CMP, AbsoluteY, 0xD9),

    (CMP, AbsoluteX, 0xDD),

    (DEC, AbsoluteX, 0xDE),

    (CPX, Immediate, 0xE0),

    (SBC, IndirectX, 0xE1),

    (CPX, ZeroPage, 0xE4),

    (SBC, ZeroPage, 0xE5),

    (INC, ZeroPage, 0xE6),

    (INX, Implicit, 0xE8),

    (SBC, Immediate, 0xE9),

    (NOP, Implicit, 0xEA),

    (CPX, Absolute, 0xEC),

    (SBC, Absolute, 0xED),

    (INC, Absolute, 0xEE),

    (BEQ, Relative, 0xF0),

    (SBC, IndirectY, 0xF1),

    (SBC, ZeroPageX, 0xF5),

    (INC, ZeroPageX, 0xF6),

    (SED, Implicit, 0xF8),

    (SBC, AbsoluteY, 0xF9),

    (SBC, AbsoluteX, 0xFD),

    (INC, AbsoluteX, 0xFE)

  ]

`

*Macros.hs*:

`

{-# LANGUAGE PatternSynonyms #-}
module Assembly.Macros (
    -- Macros
    ifnzThen, ifzThen, ifneThen, ifeqThen, ifcThen, ifncThen,
    ifmThen, ifpThen, ifoThen, ifnoThen,
    whileZ, doWhileZ,
    whileNz, doWhileNz, 
    whileC, doWhileC, 
    whileNc, doWhileNc, 
    whileM, doWhileM,
    whileP, doWhileP, 
    whileO, doWhileO,
    whileNo, doWhileNo,
    whileEq, doWhileEq, 
    whileNe, doWhileNe,
    doWhileX, 
    doWhileY,
    
    --whileAddr, doWhileAddr, whileZP, doWhileZP,
    forEachRange, 
    caseOf, caseOfA, caseOfX, caseOfY, caseOfAddr, caseOfZP, caseOfMultiBytes,
    addAto16bit, -- Add 8-bit value in A to a 16-bit memory location
    -- Helper (potentially hide later)
    makeUniqueLabel
) where

--import Assembly.List (forEach, forEachListWithIndex, mapListInPlace, mapListToNew, filterList, foldList, filterMoreThan, sumList)
import Control.Monad.IO.Class (liftIO)
import Data.Word (Word8)
import Assembly.Core
    ( adc,
      bcc,
      bcs,
      beq,
      bmi,
      bne,
      bpl,
      bvc,
      bvs,
      clc,
      cmp,
      cpx,
      cpy,
      inx,
      jmp,
      jsr,
      iny,
      inx,
      l_,
      lda,
      ldx,
      makeUniqueLabel,
      sta,
      zpLit,
      AddressRef(AddrLabel, AddrLit16),
      Asm,
      Operand(..), -- Import all constructors
      pattern Imm, -- Import the pattern synonym
      pattern AbsLabel,
      (.+), -- Import renamed operator
      (.-), -- Import renamed operator
      parens, -- Import parens if needed by macros (though unlikely)
      ArithExpr(add, sub) -- Import the class methods if needed directly (unlikely)
      )
import Prelude hiding((+), (-), and, or) -- Keep hiding Prelude's + and - if P.(+) is used elsewhere
import qualified Prelude as P ((+), (-))

-- --- Warunki ---
ifnzThen :: Asm () -> Asm ()
ifnzThen thenBlock = do
    endLabel <- makeUniqueLabel ()
    beq endLabel
    thenBlock
    l_ endLabel

ifzThen :: Asm () -> Asm ()
ifzThen thenBlock = do
    endLabel <- makeUniqueLabel ()
    bne endLabel
    thenBlock
    l_ endLabel

ifneThen :: Asm () -> Asm ()
ifneThen thenBlock = do
    endLabel <- makeUniqueLabel ()
    beq endLabel
    thenBlock
    l_ endLabel

ifeqThen :: Asm () -> Asm ()
ifeqThen thenBlock = do
    endLabel <- makeUniqueLabel ()
    bne endLabel
    thenBlock
    l_ endLabel

ifcThen :: Asm () -> Asm ()
ifcThen thenBlock = do
    endLabel <- makeUniqueLabel ()
    bcc endLabel
    thenBlock
    l_ endLabel

ifncThen :: Asm () -> Asm ()
ifncThen thenBlock = do
    endLabel <- makeUniqueLabel ()
    bcs endLabel
    thenBlock
    l_ endLabel

ifmThen :: Asm () -> Asm ()
ifmThen thenBlock = do
    endLabel <- makeUniqueLabel ()
    bpl endLabel
    thenBlock
    l_ endLabel

ifpThen :: Asm () -> Asm ()
ifpThen thenBlock = do
    endLabel <- makeUniqueLabel ()
    bmi endLabel
    thenBlock
    l_ endLabel

ifoThen :: Asm () -> Asm ()
ifoThen thenBlock = do
    endLabel <- makeUniqueLabel ()
    bvc endLabel
    thenBlock
    l_ endLabel

ifnoThen :: Asm () -> Asm ()
ifnoThen thenBlock = do
    endLabel <- makeUniqueLabel ()
    bvs endLabel
    thenBlock
    l_ endLabel

-- --- Pętle  ---
doWhileX :: Asm () -> Asm ()
doWhileX doBlock = do
    startLabel <- makeUniqueLabel ()
    l_ startLabel
    doBlock
    inx
    bne startLabel

doWhileY :: Asm () -> Asm ()
doWhileY doBlock = do
    startLabel <- makeUniqueLabel ()
    l_ startLabel
    doBlock
    iny
    bne startLabel

-- TESTING FIRST!
whileEq :: Asm () -> Asm () -> Asm ()
whileEq conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    endLabel <- makeUniqueLabel ()
    l_ startLabel
    conditionBlock
    bne endLabel
    doBlock
    jmp $ AbsLabel startLabel
    l_ endLabel

-- TESTING LAST!
doWhileEq :: Asm () -> Asm () -> Asm ()
doWhileEq conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    l_ startLabel
    doBlock
    conditionBlock
    beq startLabel

-- TESTING FIRST!
whileNe :: Asm () -> Asm () -> Asm ()
whileNe conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    endLabel <- makeUniqueLabel ()
    l_ startLabel
    conditionBlock
    beq endLabel
    doBlock
    --loop
    jmp $ AbsLabel startLabel
    l_ endLabel

-- TESTING LAST!
doWhileNe :: Asm () -> Asm () -> Asm ()
doWhileNe conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    l_ startLabel
    doBlock
    conditionBlock
    bne startLabel

whileZ :: Asm () -> Asm () -> Asm ()
whileZ = whileEq

doWhileZ :: Asm () -> Asm () -> Asm ()
doWhileZ = doWhileEq

-- TESTING FIRST!
whileNz :: Asm () -> Asm () -> Asm ()
whileNz conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    endLabel <- makeUniqueLabel ()
    l_ startLabel
    beq endLabel
    doBlock
    conditionBlock
    jmp $ AbsLabel startLabel
    l_ endLabel

-- TESTING LAST!
doWhileNz :: Asm () -> Asm () -> Asm ()
doWhileNz conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    l_ startLabel
    doBlock
    conditionBlock
    bne startLabel


whileC :: Asm () -> Asm () -> Asm ()
whileC conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    endLabel <- makeUniqueLabel ()
    l_ startLabel
    conditionBlock
    bcc endLabel
    doBlock
    jmp $ AbsLabel startLabel
    l_ endLabel

-- TESTING LAST!
doWhileC :: Asm () -> Asm () -> Asm ()
doWhileC conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    l_ startLabel
    doBlock
    conditionBlock
    bcs startLabel

whileNc :: Asm () -> Asm () -> Asm ()
whileNc conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    endLabel <- makeUniqueLabel ()
    l_ startLabel
    conditionBlock
    bcs endLabel
    doBlock
    jmp $ AbsLabel startLabel
    l_ endLabel

-- TESTING LAST!
doWhileNc :: Asm () -> Asm () -> Asm ()
doWhileNc conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    l_ startLabel
    doBlock
    conditionBlock
    bcc startLabel

whileM :: Asm () -> Asm () -> Asm ()
whileM conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    endLabel <- makeUniqueLabel ()
    l_ startLabel
    conditionBlock
    bpl endLabel
    doBlock
    jmp $ AbsLabel startLabel
    l_ endLabel

-- TESTING LAST!
doWhileM :: Asm () -> Asm () -> Asm ()
doWhileM conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    l_ startLabel
    doBlock
    conditionBlock
    bmi startLabel

-- TESTING FIRST!
whileP :: Asm () -> Asm () -> Asm ()
whileP conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    endLabel <- makeUniqueLabel ()
    l_ startLabel
    conditionBlock
    bmi endLabel
    doBlock
    jmp $ AbsLabel startLabel
    l_ endLabel

-- TESTING LAST!
doWhileP :: Asm () -> Asm () -> Asm ()
doWhileP conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    l_ startLabel
    doBlock
    conditionBlock
    bpl startLabel


whileO :: Asm () -> Asm () -> Asm ()
whileO conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    endLabel <- makeUniqueLabel ()
    l_ startLabel
    conditionBlock
    bvc endLabel
    doBlock
    jmp $ AbsLabel startLabel
    l_ endLabel

-- TESTING LAST!
doWhileO :: Asm () -> Asm () -> Asm ()
doWhileO conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    l_ startLabel
    doBlock
    conditionBlock
    bvs startLabel



whileNo :: Asm () -> Asm () -> Asm ()
whileNo conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    endLabel <- makeUniqueLabel ()
    l_ startLabel
    conditionBlock
    bvs endLabel
    doBlock
    jmp $ AbsLabel startLabel
    l_ endLabel

-- TESTING LAST!
doWhileNo :: Asm () -> Asm () -> Asm ()
doWhileNo conditionBlock doBlock = do
    startLabel <- makeUniqueLabel ()
    l_ startLabel
    doBlock
    conditionBlock
    bvc startLabel



-- Macro for 16-bit addition: Adds the 8-bit value in A to the 16-bit value at accAddr (low byte) and accAddr .+ 1 (high byte)
-- Uses ZP $00 as temporary storage for A. WARNING: Ensure ZP $00 is safe to use.
addAto16bit :: AddressRef -> Asm ()
addAto16bit accAddr = do
    let tempOperandAddr = zpLit 0x00 -- Use ZP $00 for temporary storage
    -- Store A (operand) temporarily
    sta tempOperandAddr          -- Store A (operand) temporarily
    -- Add low byte
    lda $ OpAbs accAddr          -- Load low byte of accumulator
    clc                          -- Clear carry
    adc tempOperandAddr          -- Add operand from temp storage
    sta $ OpAbs accAddr          -- Store result in low byte
    -- Add high byte with carry
    lda $ OpAbs (accAddr .+ 1)    -- Load high byte of accumulator (using .+ operator)
    adc $ Imm 0                  -- Add 0 + carry
    sta $ OpAbs (accAddr .+ 1)    -- Store result in high byte (using .+ operator)

-- --- Iteracje (bez zmian) ---
forEachRange :: Word8 -> Word8 -> (Operand -> Asm ()) -> Asm ()
forEachRange start end action = do
    ldx $ Imm start
    startLabel <- makeUniqueLabel ()
    endLabel <- makeUniqueLabel ()
    l_ startLabel
    cpx $ Imm end
    beq endLabel
    action (OpAbsX (AddrLit16 0)) -- Note: OpAbsX operand might need adjustment based on use case
    inx
    jmp $ AbsLabel startLabel
    l_ endLabel

-- --- Przełączniki (bez zmian) ---
caseOf :: (Word8 -> Asm ()) -> [(Word8, Asm ())] -> Asm ()
caseOf compareWith cases = do
    endLabel <- makeUniqueLabel ()
    casesWithLabels <- mapM (\(val, action) -> do
        caseLabel <- makeUniqueLabel ()
        return (val, caseLabel, action)
      ) cases
    mapM_ (\(val, caseLabel, _) -> do -- Removed unused 'action' from this mapM_
        compareWith val
        beq caseLabel
      ) casesWithLabels
    jmp $ AbsLabel endLabel -- Default case: jump to end if no match
    mapM_ (\(_, caseLabel, action) -> do
        l_ caseLabel
        action
        jmp $ AbsLabel endLabel -- Jump to end after executing case action
      ) casesWithLabels
    l_ endLabel

caseOfA :: [(Word8, Asm ())] -> Asm ()
caseOfA = caseOf (cmp . Imm)

caseOfX :: [(Word8, Asm ())] -> Asm ()
caseOfX = caseOf (cpx . Imm)

caseOfY :: [(Word8, Asm ())] -> Asm ()
caseOfY = caseOf (cpy . Imm)

caseOfAddr :: AddressRef -> [(Word8, Asm ())] -> Asm ()
caseOfAddr addr = caseOf (\val -> do
    lda $ OpAbs addr
    cmp $ Imm val)

caseOfZP :: AddressRef -> [(Word8, Asm ())] -> Asm ()
caseOfZP addr = caseOf (\val -> do
    lda $ OpZP addr
    cmp $ Imm val)

caseOfMultiBytes :: [(AddressRef, Word8)] -> [([(Word8, Word8)], Asm ())] -> Asm ()
caseOfMultiBytes addrBytes cases = do
    endLabel <- makeUniqueLabel ()
    defaultLabel <- makeUniqueLabel () -- Label for default case

    casesWithLabels <- mapM (\(vals, action) -> do
        caseLabel <- makeUniqueLabel ()
        matchLabel <- makeUniqueLabel ()
        noMatchLabel <- makeUniqueLabel () -- Potentially redundant now
        return (vals, caseLabel, matchLabel, noMatchLabel, action)
      ) cases

    mapM_ (\(vals, caseLabel, matchLabel, _, _) -> do
        l_ matchLabel -- Start check for this case
        -- Compare each byte pair
        sequence_ $ zipWith (\(addr, _) (val, _) -> do
            lda $ OpAbs addr
            cmp $ Imm val
            bne defaultLabel -- If any byte doesn't match, jump to default/next check
          ) addrBytes vals
        -- If all bytes matched:
        jmp $ AbsLabel caseLabel -- Jump to the action label for this case
      ) casesWithLabels

    -- Default case (if none of the above matched)
    l_ defaultLabel
    jmp $ AbsLabel endLabel -- Jump to the very end

    -- Define action blocks
    mapM_ (\(_, caseLabel, _, _, action) -> do
        l_ caseLabel
        action
        jmp $ AbsLabel endLabel -- Jump to end after action
      ) casesWithLabels

    l_ endLabel -- Final end label

-- Example usage (remains unchanged, illustrative only)
customCaseExample :: Asm ()
customCaseExample = do
    endCase <- makeUniqueLabel () -- Use a more descriptive name
    caseOf (\val -> do
        lda $ AbsLabel "enemy_health"
        cmp $ Imm val
        -- bcs jumps if A >= val (carry set). We want A <= val.
        -- So, compare and branch if *not* less than (A >= val).
        bcs endCase -- If health >= val, skip this case
        -- If we are here, health < val. For <=, we need to handle == separately
        -- A simpler way for <= might be needed depending on exact 6502 flags
        -- For this example, let's assume the logic aims for "less than"
        -- If exact <= is needed, the compare logic needs adjustment.
        ) [
            (11, do  -- Case: enemy_health < 11 (i.e., <= 10)
                jsr $ AbsLabel "enemy_critical_animation"),
            (51, do  -- Case: enemy_health < 51 (i.e., <= 50)
                 -- Important: This case comes *after* the <= 10 case.
                 -- If health is <= 10, it will match the first case and jump out.
                 -- This block only runs if health is 11 <= health <= 50.
                jsr $ AbsLabel "enemy_wounded_animation")

        ]
    l_ endCase


-- Example: Check player position (16-bit x and y coordinates)
checkSpecialPositions :: Asm ()
checkSpecialPositions = do
    caseOfMultiBytes [(AddrLabel "player_x_low", 1), (AddrLabel "player_x_high", 1), (AddrLabel "player_y_low", 1), (AddrLabel "player_y_high", 1)] [
        -- Position (100, 150) = ($64, $00, $96, $00) assuming little-endian
        ([(0x64, 1), (0x00, 1), (0x96, 1), (0x00, 1)], do
            jsr $ AbsLabel "trigger_secret_passage"),

        -- Position (200, 50) = ($C8, $00, $32, $00)
        ([(0xC8, 1), (0x00, 1), (0x32, 1), (0x00, 1)], do
            jsr $ AbsLabel "spawn_treasure_chest"),

        -- Position (150, 150) = ($96, $00, $96, $00)
        ([(0x96, 1), (0x00, 1), (0x96, 1), (0x00, 1)], do
            jsr $ AbsLabel "activate_teleporter")
        ]
`
*C64.h*:
`
module C64 (
    screenRam, colorRam,
    rasterLine, borderColor, backgroundColor,
    control1, control2, memory,
    color0, color1, color2, color3,
    _BLACK, _WHITE, _RED, _CYAN, _PURPLE,
    _GREEN, _BLUE, _YELLOW, _ORANGE, _BROWN,
    _PINK, _DARK_GREY, _GREY, _LIGHT_GREEN,
    _LIGHT_BLUE, _LIGHT_GREY
) where

import Data.Word
import Assembly.Core


-- C64 Constants
color0 = AddrLit16 0xd020
color1 = AddrLit16 0xd021
color2 = AddrLit16 0xd022
color3 = AddrLit16 0xd023


screenRam :: AddressRef
screenRam = AddrLit16 0x0400

colorRam :: AddressRef
colorRam = AddrLit16 0xd800

rasterLine :: AddressRef
rasterLine = AddrLit16 0xd012

borderColor :: AddressRef
borderColor = AddrLit16 0xd020

backgroundColor :: AddressRef
backgroundColor = AddrLit16 0xd021

-- 0xD011 Control Register #1
-- - Bit#0-#2: YSCROLL Screen Soft Scroll Vertical
-- - Bit#3: RSEL Switch betweem 25 or 24 visible rows
--          RSEL|  Display window height   | First line  | Last line
--          ----+--------------------------+-------------+----------
--            0 | 24 text lines/192 pixels |   55 (0x37)  | 246 (0xf6)
--            1 | 25 text lines/200 pixels |   51 (0x33)  | 250 (0xfa)
-- - Bit#4: DEN Switch VIC-II output on/off
-- - Bit#5: BMM Turn Bitmap Mode on/off
-- - Bit#6: ECM Turn Extended Color Mode on/off
-- - Bit#7: RST8 9th Bit for 0xD012 Rasterline counter
-- Initial Value: %10011011
control1 = AddrLit16 0xd011
-- 0xD012 RASTER Raster counter
raster = AddrLit16 0xd012 

-- 0xD016 Control register 2
-- -  Bit#0-#2: XSCROLL Screen Soft Scroll Horizontal
-- -  Bit#3: CSEL Switch betweem 40 or 38 visible columns
--           CSEL|   Display window width   | First X coo. | Last X coo.
--           ----+--------------------------+--------------+------------
--             0 | 38 characters/304 pixels |   31 (0x1f)   |  334 (0x14e)
--             1 | 40 characters/320 pixels |   24 (0x18)   |  343 (0x157)
-- -  Bit#4: MCM Turn Multicolor Mode on/off
-- -  Bit#5-#7: not used
-- Initial Value: %00001000
control2 = AddrLit16 0xd016 


-- 0xD018 VIC-II base addresses
-- - Bit#0: not used
-- - Bit#1-#3: CB Address Bits 11-13 of the Character Set (*2048)
-- - Bit#4-#7: VM Address Bits 10-13 of the Screen RAM (*1024)
-- Initial Value: %00010100
memory = AddrLit16 0xd018



-- The colors of the C64
_BLACK = 0x00 :: Word8
_WHITE = 0x01 :: Word8
_RED = 0x02 :: Word8
_CYAN = 0x03 :: Word8
_PURPLE = 0x04 :: Word8
_GREEN = 0x05 :: Word8
_BLUE = 0x06 :: Word8
_YELLOW = 0x07 :: Word8
_ORANGE = 0x08 :: Word8
_BROWN = 0x09 :: Word8
_PINK = 0x0a :: Word8 -- _LT_RED
_DARK_GREY= 0x0b :: Word8
_GREY = 0x0c :: Word8
_LIGHT_GREEN = 0x0d :: Word8
_LIGHT_BLUE = 0x0e :: Word8
_LIGHT_GREY = 0x0f :: Word8

`

*Assembly.hs*:
`

module Assembly (
    -- Re-export Core Types/State/Monad needed by users
    module Assembly.Core,
    org, -- Re-export org

    -- Higher-level functions
    runAssembler,
    generateBinary,
    formatHexBytes,
    formatBasic, -- NEW: Export the BASIC formatter

    -- Re-export List helpers
    module Assembly.List
) where


import Prelude
import Assembly.Core (hx, Asm, ProgramCounter, Label, initialAsmState, unAsm, AsmState(..), SymbolicInstruction(..), Directive(..), branchOpcode, wordToBytesLE, generateInstructionBytes, org) -- Added org to imports for re-export
import Assembly.List
import Control.Monad.State.Strict (execState)
import Data.Word (Word8, Word16)
import Data.Int (Int8)
import Data.Bits ((.&.), shiftR, shiftL)
import qualified Data.Map.Strict as Map
import Data.Foldable (foldl')
import Data.Char (ord)
import Data.Maybe (fromMaybe, mapMaybe)
import Numeric (showHex, showInt) -- Added showInt
import qualified Data.Foldable as String -- Alias dla String.length
import qualified Data.ByteString as BS
import Data.List (find, intercalate, splitAt) -- Added intercalate, splitAt
import System.IO (withBinaryFile, IOMode(WriteMode))
chunksOf :: Int -> [a] -> [[a]]
chunksOf _ [] = []
chunksOf n xs = let (ys, zs) = splitAt n xs in ys : chunksOf n zs

-- --- Binary Generation (Pass 2) --- ZAKTUALIZOWANA

unknownLbl l = "Pass 2 Error: Unknown label in branch '" ++ l ++ "'"
branchRange l pc o = "Pass 2 Error: Branch target out of range for '" ++ l ++ "' at PC " ++ hx pc ++ " (offset=" ++ show o ++ ")"

generateBinary :: AsmState -> Either String [Word8]
generateBinary finalState = foldl' processInstruction (Right []) (reverse $ asmCode finalState)
  where labels = asmLabels finalState
        calculateOffset :: ProgramCounter -> Label -> Either String Int8
        calculateOffset pc targetLabel =
            case Map.lookup targetLabel labels of
                Nothing -> Left $ unknownLbl targetLabel
                Just targetAddr ->
                    let offset = fromIntegral targetAddr - fromIntegral (pc + 2)
                    in if offset >= -128 && offset <= 127
                       then Right (fromIntegral offset)
                       else Left (branchRange targetLabel pc offset)

        processInstruction :: Either String [Word8] -> (ProgramCounter, SymbolicInstruction) -> Either String [Word8]
        processInstruction (Left err) _ = Left err
        processInstruction (Right currentBytes) (pc, instruction) =
            case instructionBytes pc instruction of
                Left err       -> Left err
                Right newBytes -> Right (currentBytes ++ newBytes)

        -- ZAKTUALIZOWANA: Używa generateInstructionBytes z Core
        instructionBytes :: ProgramCounter -> SymbolicInstruction -> Either String [Word8]
        instructionBytes _ (SLabelDef _) = Right [] -- Labels don't generate bytes
        instructionBytes _ (SBytes bs) = Right bs
        instructionBytes _ (SWords ws) = Right $ concatMap wordToBytesLE ws
        instructionBytes _ (SDirective (DOrg _)) = Right [] -- ORG directive doesn't generate bytes
        instructionBytes pc (SBranch bm targetLabel) =
            calculateOffset pc targetLabel >>= \offset -> Right [branchOpcode bm, fromIntegral (offset :: Int8)]
        instructionBytes _ (SIns m maybeOp) =
            -- Używamy teraz funkcji pomocniczej zdefiniowanej w Core.hs
            -- która korzysta z instructionTable
            generateInstructionBytes m maybeOp finalState


-- --- Assembler Runner (UPDATED) ---
-- Returns the actual start address, the generated bytes, and the labels map
runAssembler :: ProgramCounter -> Asm () -> Either String (Word16, [Word8], Map.Map Label ProgramCounter)
runAssembler initialStartAddr asmAction =
    let finalState = execState (unAsm asmAction) (initialAsmState initialStartAddr)
        orderedCode = reverse $ asmCode finalState
        -- Find the PC of the first instruction/data entry (ignoring labels/directives)
        firstRealInstruction = find (\(_, instr) -> case instr of
                                                      SLabelDef _ -> False
                                                      SDirective _ -> False
                                                      _ -> True) orderedCode
        -- Determine the actual start address for formatting
        actualStartAddress = case firstRealInstruction of
                                Just (pc, _) -> pc
                                Nothing      -> initialStartAddr -- Fallback if only labels/directives
    in case generateBinary finalState of
        Left err   -> Left err
        Right code -> Right (actualStartAddress, code, asmLabels finalState)

-- --- Formatting Utility (bez zmian) ---
formatHexBytes :: Word16 -> [Word8] -> String
formatHexBytes startAddr bytes = unlines $ formatLines 16 (zip [startAddr..] bytes)
  where
    formatLines :: Int -> [(Word16, Word8)] -> [String]
    formatLines _ [] = []
    formatLines n addrBytes =
        let (lineBytes, remainingBytes) = splitAt n addrBytes
            lineAddr = fst $ head lineBytes
            hexValues = unwords $ map (byteToHex . snd) lineBytes
            asciiChars = map (byteToAscii . snd) lineBytes
        in (addrToHex lineAddr ++ ": " ++ padRight (n * 3 - 1) hexValues ++ " ;" ++ asciiChars) : formatLines n remainingBytes

    padRight :: Int -> String -> String
    padRight len str = str ++ replicate (len - length str) ' '

    byteToHex :: Word8 -> String
    byteToHex b = let s = showHex b "" in if length s == 1 then '0':s else s

    addrToHex :: Word16 -> String
    addrToHex a = let s = showHex a "" in replicate (4 - length s) '0' ++ s

    byteToAscii :: Word8 -> Char
    byteToAscii b = let c = toEnum (fromIntegral b) in if b >= 32 && b <= 126 then c else '.'


saveAsPRG :: FilePath -> Word16 -> [Word8] -> IO ()
saveAsPRG filePath loadAddress dataBytes = 
    withBinaryFile filePath WriteMode $ \handle -> do
        -- Zapis nagłówka (2 bajty - adres załadunku w formacie little-endian)
        BS.hPut handle $ BS.pack [lowByte, highByte]
        -- Zapis danych
        BS.hPut handle $ BS.pack dataBytes
    where
        lowByte  = fromIntegral (loadAddress .&. 0xFF)         -- Młodzy bajt adresu
        highByte = fromIntegral ((loadAddress `shiftL` 8) .&. 0xFF) -- Starszy bajt adresu

-- --- NEW: C64 BASIC Formatting Utility ---
formatBasic :: Word16 -> [Word8] -> String
formatBasic startAddr bytes =
  let
    basicLines = generateBasicLines 10 startAddr bytes
  in
    unlines basicLines

generateBasicLines :: Int -> Word16 -> [Word8] -> [String]
generateBasicLines lineNum startAddr bytes =
  [ show lineNum ++ " FOR I=0 TO " ++ show (length bytes - 1) ]
  ++ generateReadPokeLines (lineNum + 10) startAddr
  ++ [ show (lineNum + 20) ++ " NEXT I" ]
  ++ generateDataLines (lineNum + 30) bytes
  ++ [ show (lineNum + 30 + length (chunksOf 16 bytes)) ++ " SYS " ++ show startAddr ]

generateDataLines :: Int -> [Word8] -> [String]
generateDataLines lineNum bytes =
  zipWith (\chunk offset -> show (lineNum + offset) ++ " DATA " ++ intercalate "," (map show chunk)) (chunksOf 16 bytes) [0..]

generateReadPokeLines :: Int -> Word16 -> [String]
generateReadPokeLines lineNum startAddr =
  [ show lineNum ++ " READ A" 
  , show (lineNum + 1) ++ " POKE " ++ show startAddr ++ "+I,A"
  ]

`

---
#Examples and main program:


*HelloWorld.hs*:
`
module C64.HelloWorld (helloWorld) where

import Assembly.Core
import Assembly(Asm)
import Assembly.Macros

startSequence = [0x0c, 0x08, 0xb5, 0x07, 0x9e, 0x20, 0x32, 0x30, 0x36, 0x32, 0x00, 0x00, 0x00]

helloWorld :: Asm ()
helloWorld = do
    org 0x0801 -- Ustawienie adresu początkowego
    db startSequence-- Initialization bytes
    lda $ Imm 0x00  -- Wyczyść ekran
    sta $ OpAbs $ AddrLit16 0xD020       -- Ustaw kolor tła
    sta $ OpAbs $ AddrLit16 0xD021       -- Ustaw kolor ramki

    ldx $ Imm 0x00   -- Licznik/index
    whileNz (lda $ AbsXLabel "text") $ do
        sta $ OpAbsX $ AddrLit16 0x0400 -- Zapisz znak na ekranie (pozycja 1024)    
        inx
    rts         -- Powrót do BASIC

    l_ "text"
    stringC64 "HELLO WORLD OF DARYO_PL2"  -- Tekst do wyświetlenia + terminator 0
    db [0x00] -- Terminator 0

`

*HorizontalBars.hs*:
`
{-# LANGUAGE OverloadedStrings #-}
module C64.HorizontalBars (horizontalBars) where

import Assembly.Core hiding (and) -- Hide Core's and if Prelude's is needed elsewhere, or qualify Core's usage
import qualified Assembly.Core as C (and) -- Import qualified if needed
import Assembly(Asm)
import Assembly.Macros
import Data.Word (Word8, Word16) -- Added Word16
import Prelude hiding (and) -- Hide Prelude's and
import C64
import Control.Monad



basicLoader :: Int -> Asm()
basicLoader addr = -- BASIC loader, don't use with --c64 option (direct BASIC output)
    let progAddress :: [Word8]; progAddress = map asc $ " " ++ show addr
    in db $ [
    0x00,                  -- Padding, BASIC loader starts at 0x0801
    0x0c, 0x08,            -- Next line $080c
    0x10, 0x00,            -- BASIC line number
    0x9e                   -- SYS token
    ]
    ++ progAddress ++      -- Address in PETSCII sequence
    [
    0x00,                  -- Terminator 0
    0x00, 0x00             -- End of BASIC program
    ]


-- Constants

-- Zero Page Variables (using fixed addresses from assembly)
scrollOffset = AddrLit16 0x02
lastColor = AddrLit16 0x03
delayCounter = AddrLit16 0x04


-- [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 
-- ...,...,
-- ...,15..., 
-- 0...,1...
-- ..., ...,
-- ,...,15...]
-- Helper for scroll table data
scrollTableData :: [Word8]
scrollTableData = concat $ replicate 2 $ concat
    [ replicate 8 0,  replicate 8 1
    , replicate 8 2,  replicate 8 3
    , replicate 8 4,  replicate 8 5
    , replicate 8 6,  replicate 8 7
    , replicate 8 8,  replicate 8 9
    , replicate 8 10, replicate 8 11
    , replicate 8 12, replicate 8 13
    , replicate 8 14, replicate 8 15
    ] 

cmpR :: AddressRef -> Word8 -> Asm()
cmpR address value = do
    lda $ OpImm value
    cmp $ OpAbs address

cmpY :: Word8  -> Asm()
cmpY value = do
    tya
    cmp $ Imm value

staRb :: AddressRef -> Word8 -> Asm() -- op <- value :: Word8
staRb op value = do
    lda $ Imm value        -- Reset delay counter
    sta $ OpAbs op

staRw :: AddressRef -> Word16 -> Asm() -- op <- value :: Word16
staRw op value = do
    lda $ Imm $ lo value -- Lower byte
    sta $ OpAbs op
    lda $ Imm $ hi value-- Upper byte
    sta $ OpAbs $ AddrLit16 (addr2word16 op + 1) -- Store upper byte in next address    


waitRaster :: Asm ()
waitRaster = do whileNe (cmpR rasterLine 100) $ do return()

scrollColors :: AddressRef -> Asm ()
scrollColors addr = do
    inc $ OpAbs scrollOffset   -- Increment scroll offset
    lda $ OpAbs scrollOffset
    C.and $ Imm 0x0f     -- Limit to 16 positions (0-15) -- Use qualified C.and
    tax                  -- Store current scroll offset in Y
    ldy $ Imm 0x00
    doWhileNe (cmpY 80) $ do
        lda $ AbsXLabel "colors_list" -- Get color from list, for x indexed by y
        sta $ OpAbsY addr -- Write color to COLOR_RAM[y]
        iny


-- The main assembly programB
horizontalBars :: Asm ()
horizontalBars = do
    org 0x0800 -- Ustawienie adresu początkowego dla BASIC loadera
    basicLoader 0x1000 -- program starts at $1000   
    db $ replicate 0x7f2 (0x00 :: Word8) -- Padding to fill the rest of the BASIC loader
    
    org 0x1000 -- Ustawienie adresu początkowego dla programu
    l_ "start"
    sei                -- Disable interrupts
    staRb borderColor _DARK_GREY
    staRb backgroundColor _DARK_GREY
    -- Initialize zero page variables
    staRb scrollOffset 0
    staRb lastColor 0
    jsr $ AbsLabel "fill_screen" -- Fill screen with initial bars

    l_ "main_loop"
    staRb delayCounter 40
    doWhileNz (dec $ OpAbs delayCounter) $ do
         jsr $ AbsLabel "delay" -- Delay loop
    waitRaster -- Sync with raster
    scrollColors colorRam
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0028)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0050)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0078)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x00a0)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x00c8)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x00f0)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0118)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0140)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0168)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0190)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x01b8)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x01e0)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0208)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0230)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0258)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0280)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x02a8)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x02d0)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x02f8)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0320)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0348)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0370)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x0398)
    scrollColors $ AddrLit16 ( addr2word16 colorRam + 0x03c0)

    inc $ OpAbs lastColor
    lda $ OpAbs lastColor
    C.and $ Imm 0x0f     -- Limit to 16 positions (0-15) -- Use qualified C.and
    sta $ OpAbs lastColor
    sta $ OpAbs scrollOffset 
    jmp $ AbsLabel "main_loop"


    -- Subroutine: Fill Screen with Bars
    l_ "fill_screen"
    ldx $ Imm 0        -- Fill entire color RAM (implicitly 1000 bytes, but loop handles 256)
    doWhileNz (inx) $ do
        txa                -- Use index as color base
        replicateM_ 6 $ ror Nothing -- Rotate right 6 times
        C.and $ Imm 0x0f     -- Limit to 16 colors (0-15) -- Use qualified C.and
        sta $ OpAbsX $ AddrLit16 (addr2word16 colorRam)      -- First quarter (0-249)
        sta $ OpAbsX $ AddrLit16 (addr2word16 colorRam + 250) -- Second quarter (250-499)
        sta $ OpAbsX $ AddrLit16 (addr2word16 colorRam + 500) -- Third quarter (500-749)
        sta $ OpAbsX $ AddrLit16 (addr2word16 colorRam + 750) -- Fourth quarter (750-999)

        lda $ Imm 0xA0 --immChar '='   -- Space character code
        sta $ OpAbsX $ AddrLit16 (addr2word16 screenRam)
        sta $ OpAbsX $ AddrLit16 (addr2word16 screenRam + 250)
        sta $ OpAbsX $ AddrLit16 (addr2word16 screenRam + 500)
        sta $ OpAbsX $ AddrLit16 (addr2word16 screenRam + 750)
    rts

    l_ "delay"
    replicateM_ 400 $ C.and $ Imm 0xef
    rts
    l_ "colors_list"
    db [_LIGHT_BLUE, _BLUE, _CYAN, _GREEN,
        _LIGHT_GREEN, _YELLOW, _ORANGE, _PINK, 
        _PURPLE, _PINK, _ORANGE, _YELLOW, 
        _LIGHT_GREEN, _GREEN, _CYAN, _BLUE ] -- Color data

    replicateM_ 20 $ db [0x00 :: Word8] -- Padding to fill the rest of the program
    -- Data: Scroll Table
    l_ "scroll_table"
    db scrollTableData

`

*Main.hs*:
`
import Assembly.Core hiding ( LabelExpression(..), ArithExpr(add, sub), org) -- Hide Core's renamed operators, LabelAdd, and org if needed
import qualified Assembly.Core as C ( ArithExpr(add, sub), LabelExpression(LabelAdd)) -- Import only needed qualified names
import Assembly(Asm, runAssembler, generateBinary, formatHexBytes, formatBasic, org) -- Import org and formatBasic from Assembly
import Assembly.List(createList, createList_, createListFromString, addToList, copyList, filterMoreThanList, sumList) -- Import from Assembly.List instead
import Assembly.Macros(addAto16bit)  -- Import addAto16bit
import qualified Data.Map.Strict as Map
import Numeric (showHex)
import C64.Examples (horizontalBars)
import Data.Word (Word16, Word8)
import Data.ByteString as BS (writeFile, toStrict)
import Data.Binary.Put (runPut, putWord16le, putWord8)
import System.FilePath (takeExtension)
import Prelude -- Explicitly import Prelude to qualify (+)
import Options.Applicative

--stack run -- --output ./c64/result.prg && cd c64 && /usr/bin/x64sc result.prg && cd ..


-- --- Command Line Options ---
data Options = Options
  { c64BasicOutput :: Bool
  , outputFile :: Maybe FilePath
  }

optionsParser :: Parser Options
optionsParser = Options
  <$> switch
     ( long "c64"
     <> help "Output in Commodore 64 BASIC format"
     )
  <*> optional (strOption
     ( long "output"
     <> short 'o'
     <> metavar "FILE"
     <> help "Output file name for binary data"
     ))

options :: ParserInfo Options
options = info (optionsParser <**> helper)
          ( fullDesc
         <> progDesc "Assemble 6502 code and output in hex or C64 BASIC"
         <> header "H6502 Assembler" )


-- --- Przykład Użycia ---

mySimpleProgram01 :: Asm ()
mySimpleProgram01 = do

    org 0xc000
    jmp $ AbsLabel "start" -- Skok do początku programu

    l_ "lista2"
    db [0x00] -- Length of the list
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding for elements

    l_ "lista3"
    db [0x00] -- Length of the list
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding for elements

    l_ "lista4"
    db [0x00] -- Length of the list
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding for elements

    l_ "lista5"
    db [0x00] -- Length of the list
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding for elements

    l_ "lista1"
    createListFromString "Hello World!"

    l_ "sumResult"
    db [0x00, 0x00] -- Wynik sumowania


    l_ "start"

    -- Test addAto16bit
    lda $ Imm 0x05       -- Load value 5 into A
    sta $ OpAbs $ AddrLabel "test16bit"  -- Store low byte
    lda $ Imm 0x00
    sta $ OpAbs $ AddrLabel "test16bit" .+ 1  -- Store high byte (0x0005) - Use C.add
    lda $ Imm 0x03       -- Load value 3 into A
    addAto16bit $ AddrLabel "test16bit"  -- Add 3 to 0x0005, result should be 0x0008

    -- Expected result: test16bit = 0x08, test16bit+1 = 0x00
    -- Test label arithmetic with parentheses
    l_ "label_arith_test"
    -- Use standard (Prelude.+) for numeric arithmetic within the offset
    lda $ OpAbs $ AddrLabel "label_arith_test" .+ (2 - (2*3))
    sta $ OpAbs $ AddrLabel "label_arith_result"

    jmp $ AbsLabel "l_cont"  -- Skok do testu

    l_ "test16bit"
    db [0x00, 0x00]  -- 16-bit storage for test

    l_ "label_arith_result"
    db [0x00]  -- Storage for label arithmetic result
    db [0x00, 0x00]  -- 16-bit storage for test

    l_ "l_cont"

    let myList2 = AddrLabel "lista2"  -- Obszar na listę 2
    let sumResult = AddrLabel "sumResult" -- Obszar na wynik sumowania
    createList_ (myList2) -- Inicjalizuj listę 2
    myList3 <- createList "lista3" -- Obszar na listę 3
    myList4 <- createList "lista4" -- Obszar na listę 4
    myList5 <- createList "lista5" -- Obszar na listę 5

    -- Dodaj elementy do list
    -- addToList myList1 (asc 'H')
    -- addToList myList1 (asc 'i')
    -- addToList myList1 (asc '!')

    addToList myList2 0x10
    addToList myList2 0x20
    addToList myList2 0x30
    addToList myList2 0x40
    addToList myList2 0x50
    addToList myList2 0x60

    -- Kopiuj listy wielokrotnie
    copyList (AddrLabel "lista1") myList3   -- Pierwsze wywołanie copyList
    copyList myList2 myList4  -- Drugie wywołanie copyList

    filterMoreThanList myList2 myList5 0x20 -- Przykład użycia filterMoreThanList
    sumList myList5 sumResult

    -- Inny kod...
    lda $ Imm 0x00
    l_ "loop_forever"
    jmp $ AbsLabel "loop_forever"






main :: IO ()
main = do
    opts <- execParser options
    let initialStartAddress = 0x8000 -- Default start address if no ORG is used
    putStrLn $ "Attempting assembly (default start: $" ++ showHex initialStartAddress "" ++ ")"
    case runAssembler initialStartAddress horizontalBars of
      Left err -> putStrLn $ "Assembly failed: \n" ++ err
      Right (actualStartAddress, byteCode, labels) -> do
        putStrLn "\n--- Assembly Successful! ---"
        putStrLn $ "Actual Start Address: $" ++ showHex actualStartAddress "" 
        putStrLn "\nLabels Defined:"
        mapM_ (\(lbl, addr) -> putStrLn $ "  " ++ lbl ++ "= $" ++ showHex addr "") (Map.toList labels)
        
        let output = if c64BasicOutput opts
                        then formatBasic actualStartAddress byteCode 
                        else formatHexBytes actualStartAddress byteCode 
        
        case outputFile opts of
          Nothing -> do
            putStrLn $ "\nGenerated ByteCode (" ++ show (length byteCode) ++ " bytes):"
            putStrLn output
          Just filePath -> do
            if takeExtension filePath == ".prg"
              then do
                let prgData = BS.toStrict $ runPut $ do
                      putWord16le (fromIntegral actualStartAddress)
                      mapM_ putWord8 byteCode
                BS.writeFile filePath prgData
                putStrLn $ "\nBytecode written to PRG file: " ++ filePath
              else do
                Prelude.writeFile filePath output
                putStrLn $ "\nBytecode written to: " ++ filePath

`
