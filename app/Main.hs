import Assembly(Asm, runAssembler, generateBinary, formatHexBytes) 
import Assembly.Core -- Importujemy wszystko z Core
import Assembly.List(createList, createList_, createListFromString, addToList, copyList, filterMoreThanList, sumList) -- Import from Assembly.List instead
import qualified Data.Map.Strict as Map
import Numeric (showHex)
import Data.Word (Word16, Word8)
-- Removed Data.Int, Data.Bits, Data.Foldable, Data.Char, Data.Maybe, GHC.*, Control.Monad.*

-- --- Przykład Użycia ---

mySimpleProgram :: Asm ()
mySimpleProgram = do

    jmp $ AbsLabel "start" -- Skok do początku programu

    l_ "lista2"
    db [0x00] -- Length of the list
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding for elements
    
    l_ "lista3"
    db [0x00] -- Length of the list
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding for elements

    l_ "lista4"
    db [0x00] -- Length of the list
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding for elements

    l_ "lista5"
    db [0x00] -- Length of the list
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding for elements

    l_ "lista1"
    createListFromString "Hello World!"

    l_ "sumResult"
    db [0x00, 0x00] -- Wynik sumowania

  
    l_ "start"

    let myList2 = AddrLabel "lista2"  -- Obszar na listę 2
    let sumResult = AddrLabel "sumResult" -- Obszar na wynik sumowania
    createList_ (myList2) -- Inicjalizuj listę 2
    myList3 <- createList "lista3" -- Obszar na listę 3
    myList4 <- createList "lista4" -- Obszar na listę 4
    myList5 <- createList "lista5" -- Obszar na listę 5

    -- Dodaj elementy do list
    -- addToList myList1 (asc 'H')
    -- addToList myList1 (asc 'i')
    -- addToList myList1 (asc '!')

    addToList myList2 0x10
    addToList myList2 0x20
    addToList myList2 0x30
    addToList myList2 0x40
    addToList myList2 0x50
    addToList myList2 0x60

    -- Kopiuj listy wielokrotnie
    copyList (AddrLabel "lista1") myList3   -- Pierwsze wywołanie copyList
    copyList myList2 myList4  -- Drugie wywołanie copyList

    filterMoreThanList myList2 myList5 0x20 -- Przykład użycia filterMoreThanList
    sumList myList2 sumResult

    -- Inny kod...
    lda $ Imm 0x00
    l_ "forever"
    jmp $ AbsLabel "forever"



     

main :: IO ()
main = do
    let startAddress = 0x8000 -- Typowy adres startowy dla programów BASIC/ML
    putStrLn $ "Assembling program starting at: $" ++ showHex startAddress ""
    case runAssembler startAddress mySimpleProgram of
      Left err -> putStrLn $ "Assembly failed: \n" ++ err
      Right (byteCode, labels) -> do
        putStrLn "\n--- Assembly Successful! ---"
        putStrLn "\nLabels Defined:"
        mapM_ (\(lbl, addr) -> putStrLn $ "  " ++ lbl ++ "= $" ++ showHex addr "") (Map.toList labels)
        -- Wypiszmy tylko pierwsze ~128 bajtów dla zwięzłości
        putStrLn $ "\nGenerated ByteCode (" ++ show (length byteCode) ++ " bytes):"
        putStrLn $ formatHexBytes startAddress byteCode
