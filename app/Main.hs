import Assembly(Asm, runAssembler, generateBinary, formatHexBytes, listCreate, listCreate_, listAdd, listForEach, listCopy, listFromString)
import Assembly.Core -- Importujemy wszystko z Core
import Assembly.Macros(filterMoreThan) -- Keep importing macros
import qualified Data.Map.Strict as Map
import Numeric (showHex)
import Data.Word (Word16, Word8)
-- Removed Data.Int, Data.Bits, Data.Foldable, Data.Char, Data.Maybe, GHC.*, Control.Monad.*

-- --- Przykład Użycia ---

mySimpleProgram :: Asm ()
mySimpleProgram = do

    jmp $ AbsLabel "start" -- Skok do początku programu

    l_ "lista2"
    db [0x00] -- Length of the list
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding for elements
    
    l_ "lista3"
    db [0x00] -- Length of the list
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding for elements

    l_ "lista4"
    db [0x00] -- Length of the list
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding for elements

    l_ "lista5"
    db [0x00] -- Length of the list
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding for elements

    l_ "lista1"
    listFromString "Hello World!"

  
    l_ "start"

    let myList2 = AddrLabel "lista2"  -- Obszar na listę 2
    listCreate_ (myList2) -- Inicjalizuj listę 2
    myList3 <- listCreate "lista3" -- Obszar na listę 3
    myList4 <- listCreate "lista4" -- Obszar na listę 4
    myList5 <- listCreate "lista5" -- Obszar na listę 5

    -- Dodaj elementy do list
    -- listAdd myList1 (asc 'H')
    -- listAdd myList1 (asc 'i')
    -- listAdd myList1 (asc '!')

    listAdd myList2 0x10
    listAdd myList2 0x20
    listAdd myList2 0x30
    listAdd myList2 0x40

    -- Kopiuj listy wielokrotnie
    listCopy (AddrLabel "lista1") myList3   -- Pierwsze wywołanie listCopy
    listCopy myList2 myList4  -- Drugie wywołanie listCopy

    filterMoreThan myList2 myList5 0x20 -- Przykład użycia filterLessThan

    -- Inny kod...
    lda $ Imm 0x00
    l_ "forever"
    jmp $ AbsLabel "forever"



     

main :: IO ()
main = do
    let startAddress = 0x8000 -- Typowy adres startowy dla programów BASIC/ML
    putStrLn $ "Assembling program starting at: $" ++ showHex startAddress ""
    case runAssembler startAddress mySimpleProgram of
      Left err -> putStrLn $ "Assembly failed: \n" ++ err
      Right (byteCode, labels) -> do
        putStrLn "\n--- Assembly Successful! ---"
        putStrLn "\nLabels Defined:"
        mapM_ (\(lbl, addr) -> putStrLn $ "  " ++ lbl ++ "= $" ++ showHex addr "") (Map.toList labels)
        -- Wypiszmy tylko pierwsze ~128 bajtów dla zwięzłości
        putStrLn $ "\nGenerated ByteCode (" ++ show (length byteCode) ++ " bytes):"
        putStrLn $ formatHexBytes startAddress byteCode
