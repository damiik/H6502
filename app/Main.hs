import Assembly
import Assembly.Macros -- Keep importing macros
import qualified Data.Map.Strict as Map
import Numeric (showHex)
import Data.Word (Word16, Word8)
-- Removed Data.Int, Data.Bits, Data.Foldable, Data.Char, Data.Maybe, GHC.*, Control.Monad.*

-- --- Przykład Użycia ---

mySimpleProgram :: Asm ()
mySimpleProgram = do
    l_ "start"
    -- Inicjalizacja list
    -- let myList1 = AddrLabel "lista1"
    let myList2 = AddrLabel "lista2"
    let myList3 = AddrLabel "lista3" -- Obszar na listę 3
    let myList4 = AddrLabel "lista4" -- Obszar na listę 4

    -- createList myList1
    createList myList2
    createList myList3
    createList myList4

    -- Dodaj elementy do list
    -- listAdd myList1 (asc 'H')
    -- listAdd myList1 (asc 'i')
    -- listAdd myList1 (asc '!')

    listAdd myList2 0x10
    listAdd myList2 0x20
    listAdd myList2 0x30
    listAdd myList2 0x40

    -- Kopiuj listy wielokrotnie
    listCopy (AddrLabel "lista1") myList3   -- Pierwsze wywołanie listCopy
    listCopy myList2 myList4  -- Drugie wywołanie listCopy

    -- Inny kod...
    lda $ Imm 0x00
    l_ "forever"
    jmp $ AbsLabel "forever"

    l_ "lista1"
    stringAsList "Hello World!"

    l_ "lista2"
    db [0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding  

    l_ "lista3"
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding

    l_ "lista4"
    db [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] -- Padding

     

main :: IO ()
main = do
    let startAddress = 0x8000 -- Typowy adres startowy dla programów BASIC/ML
    putStrLn $ "Assembling program starting at: $" ++ showHex startAddress ""
    case runAssembler startAddress mySimpleProgram of
      Left err -> putStrLn $ "Assembly failed: \n" ++ err
      Right (byteCode, labels) -> do
        putStrLn "\n--- Assembly Successful! ---"
        putStrLn "\nLabels Defined:"
        mapM_ (\(lbl, addr) -> putStrLn $ "  " ++ lbl ++ "= $" ++ showHex addr "") (Map.toList labels)
        -- Wypiszmy tylko pierwsze ~128 bajtów dla zwięzłości
        putStrLn $ "\nGenerated ByteCode (first " ++ show (min 128 (length byteCode)) ++ " bytes):"
        putStrLn $ formatHexBytes startAddress byteCode
