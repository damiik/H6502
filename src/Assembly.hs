
module Assembly (
    -- Re-export Core Types/State/Monad needed by users
    module Assembly.Core,
    org, -- Re-export org

    -- Higher-level functions
    runAssembler,
    generateBinary,
    formatHexBytes,
    formatBasic, -- NEW: Export the BASIC formatter

    -- Re-export List helpers
    module Assembly.List
) where


import Prelude
import Assembly.Core (hx, Asm, ProgramCounter, Label, initialAsmState, unAsm, AsmState(..), SymbolicInstruction(..), Directive(..), branchOpcode, wordToBytesLE, generateInstructionBytes, org) -- Added org to imports for re-export
import Assembly.List
import Control.Monad.State.Strict (execState)
import Data.Word (Word8, Word16)
import Data.Int (Int8)
import Data.Bits ((.&.), shiftR, shiftL)
import qualified Data.Map.Strict as Map
import Data.Foldable (foldl')
import Data.Char (ord)
import Data.Maybe (fromMaybe, mapMaybe)
import Numeric (showHex, showInt) -- Added showInt
import qualified Data.Foldable as String -- Alias dla String.length
import qualified Data.ByteString as BS
import Data.List (find, intercalate, splitAt) -- Added intercalate, splitAt
import System.IO (withBinaryFile, IOMode(WriteMode))
chunksOf :: Int -> [a] -> [[a]]
chunksOf _ [] = []
chunksOf n xs = let (ys, zs) = splitAt n xs in ys : chunksOf n zs

-- --- Binary Generation (Pass 2) --- ZAKTUALIZOWANA

unknownLbl l = "Pass 2 Error: Unknown label in branch '" ++ l ++ "'"
branchRange l pc o = "Pass 2 Error: Branch target out of range for '" ++ l ++ "' at PC " ++ hx pc ++ " (offset=" ++ show o ++ ")"

generateBinary :: AsmState -> Either String [Word8]
generateBinary finalState = foldl' processInstruction (Right []) (reverse $ asmCode finalState)
  where labels = asmLabels finalState
        calculateOffset :: ProgramCounter -> Label -> Either String Int8
        calculateOffset pc targetLabel =
            case Map.lookup targetLabel labels of
                Nothing -> Left $ unknownLbl targetLabel
                Just targetAddr ->
                    let offset = fromIntegral targetAddr - fromIntegral (pc + 2)
                    in if offset >= -128 && offset <= 127
                       then Right (fromIntegral offset)
                       else Left (branchRange targetLabel pc offset)

        processInstruction :: Either String [Word8] -> (ProgramCounter, SymbolicInstruction) -> Either String [Word8]
        processInstruction (Left err) _ = Left err
        processInstruction (Right currentBytes) (pc, instruction) =
            case instructionBytes pc instruction of
                Left err       -> Left err
                Right newBytes -> Right (currentBytes ++ newBytes)

        -- ZAKTUALIZOWANA: Używa generateInstructionBytes z Core
        instructionBytes :: ProgramCounter -> SymbolicInstruction -> Either String [Word8]
        instructionBytes _ (SLabelDef _) = Right [] -- Labels don't generate bytes
        instructionBytes _ (SBytes bs) = Right bs
        instructionBytes _ (SWords ws) = Right $ concatMap wordToBytesLE ws
        instructionBytes _ (SDirective (DOrg _)) = Right [] -- ORG directive doesn't generate bytes
        instructionBytes pc (SBranch bm targetLabel) =
            calculateOffset pc targetLabel >>= \offset -> Right [branchOpcode bm, fromIntegral (offset :: Int8)]
        instructionBytes _ (SIns m maybeOp) =
            -- Używamy teraz funkcji pomocniczej zdefiniowanej w Core.hs
            -- która korzysta z instructionTable
            generateInstructionBytes m maybeOp finalState


-- --- Assembler Runner (UPDATED) ---
-- Returns the actual start address, the generated bytes, and the labels map
runAssembler :: ProgramCounter -> Asm () -> Either String (Word16, [Word8], Map.Map Label ProgramCounter)
runAssembler initialStartAddr asmAction =
    let finalState = execState (unAsm asmAction) (initialAsmState initialStartAddr)
        orderedCode = reverse $ asmCode finalState
        -- Find the PC of the first instruction/data entry (ignoring labels/directives)
        firstRealInstruction = find (\(_, instr) -> case instr of
                                                      SLabelDef _ -> False
                                                      SDirective _ -> False
                                                      _ -> True) orderedCode
        -- Determine the actual start address for formatting
        actualStartAddress = case firstRealInstruction of
                                Just (pc, _) -> pc
                                Nothing      -> initialStartAddr -- Fallback if only labels/directives
    in case generateBinary finalState of
        Left err   -> Left err
        Right code -> Right (actualStartAddress, code, asmLabels finalState)

-- --- Formatting Utility (bez zmian) ---
formatHexBytes :: Word16 -> [Word8] -> String
formatHexBytes startAddr bytes = unlines $ formatLines 16 (zip [startAddr..] bytes)
  where
    formatLines :: Int -> [(Word16, Word8)] -> [String]
    formatLines _ [] = []
    formatLines n addrBytes =
        let (lineBytes, remainingBytes) = splitAt n addrBytes
            lineAddr = fst $ head lineBytes
            hexValues = unwords $ map (byteToHex . snd) lineBytes
            asciiChars = map (byteToAscii . snd) lineBytes
        in (addrToHex lineAddr ++ ": " ++ padRight (n * 3 - 1) hexValues ++ " ;" ++ asciiChars) : formatLines n remainingBytes

    padRight :: Int -> String -> String
    padRight len str = str ++ replicate (len - length str) ' '

    byteToHex :: Word8 -> String
    byteToHex b = let s = showHex b "" in if length s == 1 then '0':s else s

    addrToHex :: Word16 -> String
    addrToHex a = let s = showHex a "" in replicate (4 - length s) '0' ++ s

    byteToAscii :: Word8 -> Char
    byteToAscii b = let c = toEnum (fromIntegral b) in if b >= 32 && b <= 126 then c else '.'


saveAsPRG :: FilePath -> Word16 -> [Word8] -> IO ()
saveAsPRG filePath loadAddress dataBytes = 
    withBinaryFile filePath WriteMode $ \handle -> do
        -- Zapis nagłówka (2 bajty - adres załadunku w formacie little-endian)
        BS.hPut handle $ BS.pack [lowByte, highByte]
        -- Zapis danych
        BS.hPut handle $ BS.pack dataBytes
    where
        lowByte  = fromIntegral (loadAddress .&. 0xFF)         -- Młodzy bajt adresu
        highByte = fromIntegral ((loadAddress `shiftL` 8) .&. 0xFF) -- Starszy bajt adresu

-- --- NEW: C64 BASIC Formatting Utility ---
formatBasic :: Word16 -> [Word8] -> String
formatBasic startAddr bytes =
  let
    basicLines = generateBasicLines 10 startAddr bytes
  in
    unlines basicLines

generateBasicLines :: Int -> Word16 -> [Word8] -> [String]
generateBasicLines lineNum startAddr bytes =
  [ show lineNum ++ " FOR I=0 TO " ++ show (length bytes - 1) ]
  ++ generateReadPokeLines (lineNum + 10) startAddr
  ++ [ show (lineNum + 20) ++ " NEXT I" ]
  ++ generateDataLines (lineNum + 30) bytes
  ++ [ show (lineNum + 30 + length (chunksOf 16 bytes)) ++ " SYS " ++ show startAddr ]

generateDataLines :: Int -> [Word8] -> [String]
generateDataLines lineNum bytes =
  zipWith (\chunk offset -> show (lineNum + offset) ++ " DATA " ++ intercalate "," (map show chunk)) (chunksOf 16 bytes) [0..]

generateReadPokeLines :: Int -> Word16 -> [String]
generateReadPokeLines lineNum startAddr =
  [ show lineNum ++ " READ A" 
  , show (lineNum + 1) ++ " POKE " ++ show startAddr ++ "+I,A"
  ]
