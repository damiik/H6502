
module Assembly (
    -- Re-export Core Types/State/Monad needed by users
    module Assembly.Core,
    org, -- Re-export org

    -- Higher-level functions
    runAssembler,
    generateBinary,
    formatHexBytes,
    formatBasic, -- NEW: Export the BASIC formatter

    -- Re-export List helpers
    module Assembly.List,

) where


import Prelude
import Assembly.Core (hx, Asm, ProgramCounter, Label, initialAsmState, unAsm, AsmState(..), SymbolicInstruction(..), Directive(..), branchOpcode, wordToBytesLE, generateInstructionBytes, org) -- Added org to imports for re-export
import Assembly.List
import Control.Monad.State.Strict (execState)
import Data.Word (Word8, Word16)
import Data.Int (Int8)
import Data.Bits ((.&.), shiftR, shiftL)
import qualified Data.Map.Strict as Map
import Data.Foldable (foldl')
import Data.Char (ord)
import Data.Maybe (fromMaybe, mapMaybe)
import Numeric (showHex, showInt) -- Added showInt
import qualified Data.Foldable as String -- Alias dla String.length
import qualified Data.ByteString as BS
import Data.List (find, intercalate, splitAt) -- Added intercalate, splitAt
import System.IO (withBinaryFile, IOMode(WriteMode))
-- | Splits a list into chunks of a specified size.
chunksOf :: Int -> [a] -> [[a]]
chunksOf _ [] = []
chunksOf n xs = let (ys, zs) = splitAt n xs in ys : chunksOf n zs

-- --- Binary Generation (Pass 2) --- UPDATED

-- | Error message for an unknown label during Pass 2.
unknownLbl :: Label -> String
unknownLbl l = "Pass 2 Error: Unknown label '" ++ l ++ "'"

-- | Error message for a branch target out of range.
branchRange :: ProgramCounter -> Label -> Int -> String
branchRange pc l o = "Pass 2 Error: Branch target out of range for '" ++ l ++ "' at PC " ++ hx pc ++ " (offset=" ++ show o ++ ")"

-- | Error message for overlapping instructions.
overlapErr :: ProgramCounter -> Word16 -> String
overlapErr pc expected = "Pass 2 Error: Overlapping instructions detected at PC " ++ hx pc ++ " (expected " ++ hx expected ++ ")"

-- | Generates the final binary code from the assembler state.
-- It handles ORG directives and calculates padding.
generateBinary :: Word16 -> AsmState -> Either String [Word8]
generateBinary startAddress finalState =
    snd <$> foldl' processInstruction (Right (startAddress, [])) (reverse $ asmCode finalState)
  where
    labels = asmLabels finalState

    -- | Calculates the offset for a branch instruction.
    calculateOffset :: ProgramCounter -> Label -> Either String Int8
    calculateOffset pc targetLabel =
            case Map.lookup targetLabel labels of
                Nothing -> Left $ unknownLbl targetLabel
                Just targetAddr ->
                    let offset = fromIntegral targetAddr - fromIntegral (pc + 2)
                    in if offset >= -128 && offset <= 127
                       then Right (fromIntegral offset)
                       else Left $ branchRange pc targetLabel offset

    -- | Processes a single symbolic instruction during binary generation.
    processInstruction :: Either String (Word16, [Word8]) -> (ProgramCounter, SymbolicInstruction) -> Either String (Word16, [Word8])
    processInstruction (Left err) _ = Left err
    processInstruction (Right (expectedAddr, currentBytes)) (pc, instruction) = do
        -- Calculate padding if needed
        let gapSize = fromIntegral pc - fromIntegral expectedAddr
        paddingBytes <- case compare gapSize 0 of
            LT -> Left $ overlapErr pc expectedAddr -- Error if PC goes backward
            EQ -> Right []                          -- No gap
            GT -> Right $ replicate gapSize 0x00    -- Fill gap with 0x00

        -- Get bytes for the current instruction
        newBytes <- instructionBytes pc instruction

        -- Calculate the next expected address
        let nextExpectedAddr = pc + fromIntegral (length newBytes)

        -- Append padding and new bytes
        Right (nextExpectedAddr, currentBytes ++ paddingBytes ++ newBytes)

    -- | Generates the byte representation for a symbolic instruction.
    instructionBytes :: ProgramCounter -> SymbolicInstruction -> Either String [Word8]
    instructionBytes _ (SLabelDef _) = Right [] -- Labels don't generate bytes
    instructionBytes _ (SBytes bs) = Right bs
    instructionBytes _ (SWords ws) = Right $ concatMap wordToBytesLE ws
    instructionBytes _ (SDirective (DOrg _)) = Right [] -- ORG directive doesn't generate bytes
    instructionBytes pc (SBranch bm targetLabel) =
        calculateOffset pc targetLabel >>= \offset -> Right [branchOpcode bm, fromIntegral (offset :: Int8)]
    instructionBytes _ (SIns m maybeOp) =
        -- Using the helper function defined in Core.hs
        -- which uses instructionTable
        generateInstructionBytes m maybeOp finalState


-- --- Assembler Runner (UPDATED) ---
-- | Runs the assembler action and generates the binary code and label map.
-- Returns the actual start address, the generated bytes, and the labels map
runAssembler :: ProgramCounter -> Asm () -> Either String (Word16, [Word8], Map.Map Label ProgramCounter)
runAssembler initialStartAddr asmAction =
    let finalState = execState (unAsm asmAction) (initialAsmState initialStartAddr)
        orderedCode = reverse $ asmCode finalState
        -- Find the PC of the first instruction/data entry (ignoring labels/directives)
        firstRealInstructionPC = fst <$> find (\(_, instr) -> case instr of
                                                                    SLabelDef _ -> False
                                                                    SDirective _ -> False
                                                                    _ -> True) orderedCode
        -- Determine the actual start address for formatting and binary generation start point
        actualStartAddress = fromMaybe initialStartAddr firstRealInstructionPC
    in case generateBinary actualStartAddress finalState of -- Pass actualStartAddress
        Left err   -> Left err
        Right code -> Right (actualStartAddress, code, asmLabels finalState)

-- --- Formatting Utility ---
-- | Formats the generated bytes as a hex dump with ASCII representation.
formatHexBytes :: Word16 -> [Word8] -> String
formatHexBytes startAddr bytes = unlines $ formatLines 16 (zip [startAddr..] bytes)
  where
    formatLines :: Int -> [(Word16, Word8)] -> [String]
    formatLines _ [] = []
    formatLines n addrBytes =
        let (lineBytes, remainingBytes) = splitAt n addrBytes
            lineAddr = fst $ head lineBytes
            hexValues = unwords $ map (byteToHex . snd) lineBytes
            asciiChars = map (byteToAscii . snd) lineBytes
        in (addrToHex lineAddr ++ ": " ++ padRight (n * 3 - 1) hexValues ++ " ;" ++ asciiChars) : formatLines n remainingBytes

    -- | Pads a string with spaces on the right.
    padRight :: Int -> String -> String
    padRight len str = str ++ replicate (len - length str) ' '

    -- | Converts a byte to its two-character hexadecimal string representation.
    byteToHex :: Word8 -> String
    byteToHex b = let s = showHex b "" in if length s == 1 then '0':s else s

    -- | Converts a word to its four-character hexadecimal string representation.
    addrToHex :: Word16 -> String
    addrToHex a = let s = showHex a "" in replicate (4 - length s) '0' ++ s

    -- | Converts a byte to its ASCII character representation, or '.' if non-printable.
    byteToAscii :: Word8 -> Char
    byteToAscii b = let c = toEnum (fromIntegral b) in if b >= 32 && b <= 126 then c else '.'

-- | Saves the generated binary data to a .prg file with a C64 load address header.
saveAsPRG :: FilePath -> Word16 -> [Word8] -> IO ()
saveAsPRG filePath loadAddress dataBytes =
    withBinaryFile filePath WriteMode $ \handle -> do
        -- Write header (2 bytes - load address in little-endian format)
        BS.hPut handle $ BS.pack [lowByte, highByte]
        -- Write data
        BS.hPut handle $ BS.pack dataBytes
    where
        lowByte  = fromIntegral (loadAddress .&. 0xFF)         -- Low byte of address
        highByte = fromIntegral ((loadAddress `shiftR` 8) .&. 0xFF) -- High byte of address

-- --- NEW: C64 BASIC Formatting Utility ---
-- | Formats the generated bytes into a C64 BASIC program that pokes the bytes into memory.
formatBasic :: Word16 -> [Word8] -> String
formatBasic startAddr bytes =
  let
    basicLines = generateBasicLines 10 startAddr bytes
  in
    unlines basicLines

-- | Generates the lines of the BASIC program.
generateBasicLines :: Int -> Word16 -> [Word8] -> [String]
generateBasicLines lineNum startAddr bytes =
  [ show lineNum ++ " FOR I=0 TO " ++ show (length bytes - 1) ]
  ++ generateReadPokeLines (lineNum + 10) startAddr
  ++ [ show (lineNum + 20) ++ " NEXT I" ]
  ++ generateDataLines (lineNum + 30) bytes
  ++ [ show (lineNum + 30 + length (chunksOf 16 bytes)) ++ " SYS " ++ show startAddr ]

-- | Generates the DATA lines for the BASIC program.
generateDataLines :: Int -> [Word8] -> [String]
generateDataLines lineNum bytes =
  zipWith (\chunk offset -> show (lineNum + offset) ++ " DATA " ++ intercalate "," (map show chunk)) (chunksOf 16 bytes) [0..]

-- | Generates the READ and POKE lines for the BASIC program.
generateReadPokeLines :: Int -> Word16 -> [String]
generateReadPokeLines lineNum startAddr =
  [ show lineNum ++ " READ A"
  , show (lineNum + 1) ++ " POKE " ++ show startAddr ++ "+I,A"
  ]
