
module Assembly (
    -- Re-export Core Types/State/Monad needed by users
    module Assembly.Core,
    org, -- Re-export org

    -- Higher-level functions
    runAssembler,
    generateBinary,
    formatHexBytes,
    formatBasic, -- NEW: Export the BASIC formatter

    -- Re-export List helpers
    module Assembly.List
) where


import Prelude
import Assembly.Core (hx, Asm, ProgramCounter, Label, initialAsmState, unAsm, AsmState(..), SymbolicInstruction(..), Directive(..), branchOpcode, wordToBytesLE, generateInstructionBytes, org) -- Added org to imports for re-export
import Assembly.List
import Control.Monad.State.Strict (execState)
import Data.Word (Word8, Word16)
import Data.Int (Int8)
import Data.Bits ((.&.), shiftR, shiftL)
import qualified Data.Map.Strict as Map
import Data.Foldable (foldl')
import Data.Char (ord)
import Data.Maybe (fromMaybe, mapMaybe)
import Numeric (showHex, showInt) -- Added showInt
import qualified Data.Foldable as String -- Alias dla String.length
import qualified Data.ByteString as BS
import Data.List (find, intercalate, splitAt) -- Added intercalate, splitAt
import System.IO (withBinaryFile, IOMode(WriteMode))
chunksOf :: Int -> [a] -> [[a]]
chunksOf _ [] = []
chunksOf n xs = let (ys, zs) = splitAt n xs in ys : chunksOf n zs

-- --- Binary Generation (Pass 2) --- ZAKTUALIZOWANA

unknownLbl l = "Pass 2 Error: Unknown label '" ++ l ++ "'"
branchRange l pc o = "Pass 2 Error: Branch target out of range for '" ++ l ++ "' at PC " ++ hx pc ++ " (offset=" ++ show o ++ ")"
overlapErr pc expected = "Pass 2 Error: Overlapping instructions detected at PC " ++ hx pc ++ " (expected " ++ hx expected ++ ")"

-- generateBinary (Updated to handle ORG padding)
generateBinary :: Word16 -> AsmState -> Either String [Word8]
generateBinary startAddress finalState =
    snd <$> foldl' processInstruction (Right (startAddress, [])) (reverse $ asmCode finalState)
  where
    labels = asmLabels finalState

    calculateOffset :: ProgramCounter -> Label -> Either String Int8
    calculateOffset pc targetLabel =
            case Map.lookup targetLabel labels of
                Nothing -> Left $ unknownLbl targetLabel
                Just targetAddr ->
                    let offset = fromIntegral targetAddr - fromIntegral (pc + 2)
                    in if offset >= -128 && offset <= 127
                       then Right (fromIntegral offset)
                       else Left $ branchRange targetLabel pc offset

    processInstruction :: Either String (Word16, [Word8]) -> (ProgramCounter, SymbolicInstruction) -> Either String (Word16, [Word8])
    processInstruction (Left err) _ = Left err
    processInstruction (Right (expectedAddr, currentBytes)) (pc, instruction) = do
        -- Calculate padding if needed
        let gapSize = fromIntegral pc - fromIntegral expectedAddr
        paddingBytes <- case compare gapSize 0 of
            LT -> Left $ overlapErr pc expectedAddr -- Error if PC goes backward
            EQ -> Right []                          -- No gap
            GT -> Right $ replicate gapSize 0x00    -- Fill gap with 0x00

        -- Get bytes for the current instruction
        newBytes <- instructionBytes pc instruction

        -- Calculate the next expected address
        let nextExpectedAddr = pc + fromIntegral (length newBytes)

        -- Append padding and new bytes
        Right (nextExpectedAddr, currentBytes ++ paddingBytes ++ newBytes)

    instructionBytes :: ProgramCounter -> SymbolicInstruction -> Either String [Word8]
    instructionBytes _ (SLabelDef _) = Right [] -- Labels don't generate bytes
    instructionBytes _ (SBytes bs) = Right bs
    instructionBytes _ (SWords ws) = Right $ concatMap wordToBytesLE ws
    instructionBytes _ (SDirective (DOrg _)) = Right [] -- ORG directive doesn't generate bytes
    instructionBytes pc (SBranch bm targetLabel) =
        calculateOffset pc targetLabel >>= \offset -> Right [branchOpcode bm, fromIntegral (offset :: Int8)]
    instructionBytes _ (SIns m maybeOp) =
        -- Używamy teraz funkcji pomocniczej zdefiniowanej w Core.hs
        -- która korzysta z instructionTable
        generateInstructionBytes m maybeOp finalState


-- --- Assembler Runner (UPDATED) ---
-- Returns the actual start address, the generated bytes, and the labels map
runAssembler :: ProgramCounter -> Asm () -> Either String (Word16, [Word8], Map.Map Label ProgramCounter)
runAssembler initialStartAddr asmAction =
    let finalState = execState (unAsm asmAction) (initialAsmState initialStartAddr)
        orderedCode = reverse $ asmCode finalState
        -- Find the PC of the first instruction/data entry (ignoring labels/directives)
        firstRealInstructionPC = fst <$> find (\(_, instr) -> case instr of
                                                                    SLabelDef _ -> False
                                                                    SDirective _ -> False
                                                                    _ -> True) orderedCode
        -- Determine the actual start address for formatting and binary generation start point
        actualStartAddress = fromMaybe initialStartAddr firstRealInstructionPC
    in case generateBinary actualStartAddress finalState of -- Pass actualStartAddress
        Left err   -> Left err
        Right code -> Right (actualStartAddress, code, asmLabels finalState)

-- --- Formatting Utility ---
formatHexBytes :: Word16 -> [Word8] -> String
formatHexBytes startAddr bytes = unlines $ formatLines 16 (zip [startAddr..] bytes)
  where
    formatLines :: Int -> [(Word16, Word8)] -> [String]
    formatLines _ [] = []
    formatLines n addrBytes =
        let (lineBytes, remainingBytes) = splitAt n addrBytes
            lineAddr = fst $ head lineBytes
            hexValues = unwords $ map (byteToHex . snd) lineBytes
            asciiChars = map (byteToAscii . snd) lineBytes
        in (addrToHex lineAddr ++ ": " ++ padRight (n * 3 - 1) hexValues ++ " ;" ++ asciiChars) : formatLines n remainingBytes

    padRight :: Int -> String -> String
    padRight len str = str ++ replicate (len - length str) ' '

    byteToHex :: Word8 -> String
    byteToHex b = let s = showHex b "" in if length s == 1 then '0':s else s

    addrToHex :: Word16 -> String
    addrToHex a = let s = showHex a "" in replicate (4 - length s) '0' ++ s

    byteToAscii :: Word8 -> Char
    byteToAscii b = let c = toEnum (fromIntegral b) in if b >= 32 && b <= 126 then c else '.'


saveAsPRG :: FilePath -> Word16 -> [Word8] -> IO ()
saveAsPRG filePath loadAddress dataBytes = 
    withBinaryFile filePath WriteMode $ \handle -> do
        -- Zapis nagłówka (2 bajty - adres załadunku w formacie little-endian)
        BS.hPut handle $ BS.pack [lowByte, highByte]
        -- Zapis danych
        BS.hPut handle $ BS.pack dataBytes
    where
        lowByte  = fromIntegral (loadAddress .&. 0xFF)         -- Młodzy bajt adresu
        highByte = fromIntegral ((loadAddress `shiftL` 8) .&. 0xFF) -- Starszy bajt adresu

-- --- NEW: C64 BASIC Formatting Utility ---
formatBasic :: Word16 -> [Word8] -> String
formatBasic startAddr bytes =
  let
    basicLines = generateBasicLines 10 startAddr bytes
  in
    unlines basicLines

generateBasicLines :: Int -> Word16 -> [Word8] -> [String]
generateBasicLines lineNum startAddr bytes =
  [ show lineNum ++ " FOR I=0 TO " ++ show (length bytes - 1) ]
  ++ generateReadPokeLines (lineNum + 10) startAddr
  ++ [ show (lineNum + 20) ++ " NEXT I" ]
  ++ generateDataLines (lineNum + 30) bytes
  ++ [ show (lineNum + 30 + length (chunksOf 16 bytes)) ++ " SYS " ++ show startAddr ]

generateDataLines :: Int -> [Word8] -> [String]
generateDataLines lineNum bytes =
  zipWith (\chunk offset -> show (lineNum + offset) ++ " DATA " ++ intercalate "," (map show chunk)) (chunksOf 16 bytes) [0..]

generateReadPokeLines :: Int -> Word16 -> [String]
generateReadPokeLines lineNum startAddr =
  [ show lineNum ++ " READ A" 
  , show (lineNum + 1) ++ " POKE " ++ show startAddr ++ "+I,A"
  ]
